Testcase.create(:name => "github_650-850_4_p0.java", :java => "// https://searchcode.com/api/result/110747437/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_450-650_1_p2.java", :java => "// https://searchcode.com/api/result/87881700/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_151_p0.java", :java => "// https://searchcode.com/api/result/74259363/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_398_p0.java", :java => "// https://searchcode.com/api/result/93911511/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_397_p0.java", :java => "// https://searchcode.com/api/result/93911507/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_158_p0.java", :java => "// https://searchcode.com/api/result/140067130/\n\t\tpublic void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile( values.hasNext() ) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect( key, new IntWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_0_p2.java", :java => "// https://searchcode.com/api/result/74259923/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_22_p0.java", :java => "// https://searchcode.com/api/result/99975914/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble stdDev = 0;\n\t\t\tdouble sumSqr = 0;\n\t\t\tdouble count = 0;\n\t\t\tdouble mean = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tdouble value = values.next().get();\n\t\t\t\tsumSqr += value*value;\n\t\t\t\tsum += value;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmean = sum/count;\n\t\t\tstdDev = Math.sqrt((sumSqr-count*mean*mean)/count);\n\t\t\toutput.collect(key, new DoubleWritable(stdDev));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_132_p0.java", :java => "// https://searchcode.com/api/result/65246202/\n    public void reduce( Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n      throws IOException\n    {\n      long sum = 0;\n\n      while ( values.hasNext( ) )\n        {\n          LongWritable value = values.next( );\n          \n          sum += value.get( );\n        }\n      \n      output.collect( key, new LongWritable( sum ) );\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p6.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final LongWritable key, final Iterator<DoubleWritable> values, final OutputCollector<LongWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "LongWritable", :t2 => "DoubleWritable", :t3 => "LongWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_317_p0.java", :java => "// https://searchcode.com/api/result/100948350/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tcollect.collect(key, new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p2.java", :java => "// https://searchcode.com/api/result/110747437/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_320_p0.java", :java => "// https://searchcode.com/api/result/100948377/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, Text> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\tint counter = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tfloat avg = (float) sum/counter;\n\t\t\tString emitValue = sum + \"\t\" + avg;\n\t\t\tcollect.collect(key, new Text(emitValue));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_159_p0.java", :java => "// https://searchcode.com/api/result/140067148/\n\t\tpublic void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile( values.hasNext() ) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect( key, new IntWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p1.java", :java => "// https://searchcode.com/api/result/110747437/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int count = 0;\n      while (it.hasNext()) {\n        it.next();\n        count++;\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(count));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_39_p0.java", :java => "// https://searchcode.com/api/result/133129611/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_5_p0.java", :java => "// https://searchcode.com/api/result/49661265/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_60_p0.java", :java => "// https://searchcode.com/api/result/94159078/\n        public void reduce(IntWritable key, Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, Reporter reporter) throws IOException {\n            int count = 0;\n            while (values.hasNext()) count += values.next().get();\n            output.collect(key, new IntWritable(count));\n        }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_34_p0.java", :java => "// https://searchcode.com/api/result/94159083/\n        public void reduce( Text key, Iterator<IntWritable> values,\n                            OutputCollector<Text, IntWritable> output,\n                            Reporter reporter) throws IOException\n        {\n            // Iterate over all of the values (counts of occurrences of this word)\n            int count = 0;\n            while( values.hasNext() )\n            {\n                // Add the value to our count\n                count += values.next().get();\n            }\n\n            // Output the word with its count (wrapped in an IntWritable)\n            output.collect( key, new IntWritable( count ) );\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_665_p0.java", :java => "// https://searchcode.com/api/result/69347180/\n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n   \n    double sum = 0.0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n    output.collect(key, new DoubleWritable(sum));\n  }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_43_p3.java", :java => "// https://searchcode.com/api/result/48924584/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_value = values.next().get();\n\t\t\t\tsum += cur_value;\n\t\t\t}\n\n\t\t\toutput.collect( key, new IntWritable(sum) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_199_p0.java", :java => "// https://searchcode.com/api/result/10576179/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_64_p1.java", :java => "// https://searchcode.com/api/result/48924600/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(count) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_256_p0.java", :java => "// https://searchcode.com/api/result/74993295/\n\n        public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n                throws IOException {\n            long total = 0;\n            while (values.hasNext()) {\n                total += values.next().get();\n                //output.collect(key, values.next());\n            }\n            output.collect(key, new LongWritable(total));\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_395_p0.java", :java => "// https://searchcode.com/api/result/93911496/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "googleCode_50-250_15_p0.java", :java => "// https://searchcode.com/api/result/11953651/\n    \n    /*[*/private NcdcStationMetadata metadata;/*]*/\n    \n    public void configure(JobConf conf) {\n      metadata = new NcdcStationMetadata();\n      try {\n        metadata.initialize(new File(\"stations-fixed-width.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }/*]*/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n        OutputCollector<Text, IntWritable> output, Reporter reporter)\n        throws IOException {\n      \n      /*[*/String stationName = metadata.getStationName(key.toString());/*]*/\n      \n      int maxValue = Integer.MIN_VALUE;\n      while (values.hasNext()) {\n        maxValue = Math.max(maxValue, values.next().get());\n      }\n      output.collect(new Text(/*[*/stationName/*]*/), new IntWritable(maxValue));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_446_p0.java", :java => "// https://searchcode.com/api/result/100948399/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0L;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tvword.set(sum);\n\t\t\tcollector.collect(key, vword);\n\t\t}\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_152_p0.java", :java => "// https://searchcode.com/api/result/49663142/\n\n     public void reduce(Text key, Iterator<IntWritable> values,\n                        OutputCollector<Text, IntWritable> output,\n                        Reporter reporter) throws IOException {\n       int sum = 0;\n       while (values.hasNext()) {\n         sum += values.next().get();\n       }\n       output.collect(key, new IntWritable(sum));\n     }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_578_p0.java", :java => "// https://searchcode.com/api/result/64321964/\n    LongWritable longWritable = new LongWritable(0);\n\n    public void reduce(Text key, Iterator<LongWritable> values,\n                       OutputCollector<Text, LongWritable> collector,\n                       Reporter reporter) throws IOException {\n\n      long total = 0;\n      while (values.hasNext()) {\n        total += values.next().get();\n      }\n\n      longWritable.set(total);\n      collector.collect(key, longWritable);\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_42_p0.java", :java => "// https://searchcode.com/api/result/121693720/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t            if (key.toString().equals(\"Haze\")) {\n\t                int sum = 0;\n\t                while (values.hasNext()) {\n\t                    sum += values.next().get();\n\t                }\n\t                output.collect(key, new IntWritable(sum));\n\t            }\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_63_p1.java", :java => "// https://searchcode.com/api/result/48924589/\n\t\tpublic void reduce (final LongWritable key, final Iterator<DoubleWritable> values, final OutputCollector<LongWritable, Text> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i;\n\t\t\tdouble next_rank = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tString cur_value_str = values.next().toString();\n\t\t\t\tnext_rank += Double.parseDouble( cur_value_str ) ;\n\t\t\t}\n\n\t\t\toutput.collect( key, new Text( \"v\" + next_rank ) );\n\t\t}\n", :t1 => "LongWritable", :t2 => "DoubleWritable", :t3 => "LongWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_0_p0.java", :java => "// https://searchcode.com/api/result/57173764/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_211_p0.java", :java => "// https://searchcode.com/api/result/110743700/\n\n  public void reduce(Text key, Iterator<LongWritable> values,\n                     OutputCollector<Text, LongWritable> output,\n                     Reporter reporter)\n    throws IOException {\n\n    // sum all values for this key\n    long sum = 0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n\n    // output sum\n    output.collect(key, new LongWritable(sum));\n  }\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_54_p0.java", :java => "// https://searchcode.com/api/result/50437955/\nLongWritable val = new LongWritable();\n\npublic void configure(JobConf job) { }\npublic void close() {}\npublic void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n    throws IOException {\n    val.set(0L);\n    String k = ((Text)key).toString();\n    if (!k.equals(\"s\")) {\n        while (values.hasNext()) {\n            LongWritable cnt = (LongWritable)values.next();\n            val.set(val.get() + cnt.get());\n        }\n        output.collect(key, val);\n    } else {\n        long total = 0;\n        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n        while (values.hasNext()) {\n            LongWritable cnt = (LongWritable)values.next();\n            if (cnt.get() < min) min = cnt.get();\n            if (cnt.get() > max) max = cnt.get();\n            total += cnt.get();\n        }\n        output.collect(new Text(\"scn\"), new LongWritable(min));\n        output.collect(new Text(\"scx\"), new LongWritable(max));\n        output.collect(new Text(\"sct\"), new LongWritable(total));\n    }\n}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_41_p4.java", :java => "// https://searchcode.com/api/result/48924603/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(count) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_52_p1.java", :java => "// https://searchcode.com/api/result/48925527/\n    public void configure(JobConf job) {}\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n            throws IOException {\n\n      String k = ((Text) key).toString();\n      if (k.equals(\"T\")) {\n        // sum all values for this key\n        long sum = 0;\n        while (values.hasNext()) {\n          sum += ((LongWritable) values.next()).get();\n        }\n        // output sum\n        output.collect(key, new LongWritable(sum));\n      } else if (k.startsWith(\"status\") || k.startsWith(\"retry\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scx\")) {\n        LongWritable cnt = new LongWritable(Long.MIN_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() < val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scn\")) {\n        LongWritable cnt = new LongWritable(Long.MAX_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() > val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"sct\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "googleCode_50-250_0_p0.java", :java => "// https://searchcode.com/api/result/12375307/\n \t    public void reduce (LongWritable jobId, Iterator<LongWritable> values, OutputCollector<LongWritable, LongWritable> output, Reporter reporter) throws IOException\n        {\n            while(values.hasNext())\n            {\n                LongWritable totalJobs = values.next();\n                output.collect(jobId, totalJobs);\n            }\n \t    }\n", :t1 => "LongWritable", :t2 => "LongWritable", :t3 => "LongWritable", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "bitbucket_250-450_50_p0.java", :java => "// https://searchcode.com/api/result/49662007/\n\nprivate long numInside = 0;\nprivate long numOutside = 0;\n\n/** Store job configuration. */\npublic void configure(JobConf job) {\n}\n\n/**\n * Accumulate number of points inside/outside results from the mappers.\n * @param isInside Is the points inside? \n * @param values An iterator to a list of point counts\n * @param output dummy, not used here.\n * @param reporter\n */\npublic void reduce(BooleanWritable isInside,\n        Iterator<LongWritable> values,\n        OutputCollector<Integer, Integer> output,\n        Reporter reporter) throws IOException {\n    if (isInside.get()) {\n        for(; values.hasNext(); numInside += values.next().get());\n    } else {\n        for(; values.hasNext(); numOutside += values.next().get());\n    }\n}\n\n/**\n * Reduce task done, write output to a file.\n */\npublic void close() throws IOException {\n}\n", :t1 => "BooleanWritable", :t2 => "LongWritable", :t3 => "Integer", :t4 => "Integer", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_223_p0.java", :java => "// https://searchcode.com/api/result/93179613/\n\n\t\tpublic void reduce(Text k, Iterator<LongWritable> vs, OutputCollector<Text, LongWritable> out, Reporter rep)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tlong cnt = 0;\n\t\t\twhile(vs.hasNext()) {\n\t\t\t\tcnt += vs.next().get();\n\t\t\t}\n\t\t\tout.collect(k, new LongWritable(cnt));\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\t\t\n\t\tpublic void close() throws IOException { }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_0_p2.java", :java => "// https://searchcode.com/api/result/57173764/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_64_p0.java", :java => "// https://searchcode.com/api/result/48924600/\nstatic int InDeg = 1, OutDeg = 2, InOutDeg = 3;\n\nprivate final IntWritable one_int = new IntWritable(1);\n\nint deg_type = 0;\n\npublic void configure(JobConf job) {\n    deg_type = Integer.parseInt(job.get(\"deg_type\"));\n\n    System.out.println(\"RedPass1 : configure is called. degtype = \" + deg_type );\n}\n\npublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n{\n    int degree = 0;\n\n    if( deg_type != InOutDeg) {\n        while (values.hasNext()) {\n            int cur_degree = values.next().get();\n            degree += cur_degree;\n        }\n\n        output.collect(key, new IntWritable(degree) );\n    } else { // deg_type == InOutDeg\n        Set<Integer> outEdgeSet = new TreeSet<Integer>();\n        while (values.hasNext()) {\n            int cur_outedge = values.next().get();\n            outEdgeSet.add( cur_outedge );\n        }\n\n        output.collect(key, new IntWritable(outEdgeSet.size()) );\n    }\n}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_40_p4.java", :java => "// https://searchcode.com/api/result/48924602/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\tIntWritable count_int = new IntWritable(count);\n\t\t\toutput.collect(key, count_int );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_166_p0.java", :java => "// https://searchcode.com/api/result/49661309/\n  \n    static int numSeen;\n    static int actualSum;\n    public void configure(JobConf job) { }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> val,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      actualSum += key.get(); // keep the running count of the seen values\n      numSeen++; // number of values seen so far\n      \n      // using \'1+2+3+...n =  n*(n+1)/2\' to validate\n      int expectedSum = numSeen * (numSeen + 1) / 2;\n      if (expectedSum != actualSum) {\n        throw new IOException(\"Collect test failed!! Ordering mismatch.\");\n      }\n    }\n\n    public void close() { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_244_p0.java", :java => "// https://searchcode.com/api/result/73390634/\n        private static long KmerThreshold = 1 ;\n        private static int K = 1;\n        private static long Readlen = 36;\n\t\tpublic void configure(JobConf job) {     \n            Readlen = Long.parseLong(job.get(\"READLENGTH\"));\n\t\t}\n        \n\t\tpublic void reduce(Text prefix, Iterator<IntWritable> iter,\n\t\t\t\t\t\t   OutputCollector<Text, IntWritable> output, Reporter reporter)\n\t\t\t\t\t\t   throws IOException\n\t\t{\n            int sum =0;\n            int untrust_count = 0;\n            int TRUST = 1;\n            while(iter.hasNext())\n\t\t\t{\n                int frequency = iter.next().get();\n                if (frequency <= KmerThreshold) {\n                    untrust_count = untrust_count + 1;\n                    TRUST = 0;\n                    break;\n                }\n            }\n            \n            output.collect(prefix, new IntWritable(TRUST));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_162_p0.java", :java => "// https://searchcode.com/api/result/46998531/\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            output.collect(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_435_p0.java", :java => "// https://searchcode.com/api/result/100948347/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0L;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tvword.set(sum);\n\t\t\tcollector.collect(key, vword);\n\t\t}\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_0_p1.java", :java => "// https://searchcode.com/api/result/74259923/\npublic void configure(JobConf job) {\n}\n\npublic void reduce(IntWritable key, Iterator<IntWritable> it,\n        OutputCollector<IntWritable, IntWritable> out,\n        Reporter reporter) throws IOException {\n    int keyint = key.get();\n    int count = 0;\n    while (it.hasNext()) {\n        it.next();\n        count++;\n    }\n    out.collect(new IntWritable(keyint), new IntWritable(count));\n}\npublic void close() {\n}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_62_p0.java", :java => "// https://searchcode.com/api/result/46344310/\n\n        public void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text,IntWritable> output , Reporter reporter ) \n            throws IOException {\n\n            int sum = 0;\n            while ( values.hasNext() ) {\n                sum += values.next().get();\n            }\n            output.collect( key , new IntWritable( sum ) );\n        }\n\n        public void configure(JobConf job) {}\n        public void close(){}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_195_p0.java", :java => "// https://searchcode.com/api/result/49661797/\n\npublic void reduce(Text key, Iterator<LongWritable> values,\n        OutputCollector<Text, LongWritable> output,\n        Reporter reporter)\n    throws IOException {\n\n    // sum all values for this key\n    long sum = 0;\n    while (values.hasNext()) {\n        sum += values.next().get();\n    }\n\n    // output sum\n    output.collect(key, new LongWritable(sum));\n}\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_39_p0.java", :java => "// https://searchcode.com/api/result/99975954/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint maxTemp = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tint nextTemp = values.next().get();\n\t\t\t\tif (nextTemp > maxTemp)\n\t\t\t\t\tmaxTemp = nextTemp;\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(maxTemp));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_163_p0.java", :java => "// https://searchcode.com/api/result/110747418/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_54_p1.java", :java => "// https://searchcode.com/api/result/50437955/\n    public void configure(JobConf job) {}\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n            throws IOException {\n\n      String k = ((Text) key).toString();\n      if (k.equals(\"T\")) {\n        // sum all values for this key\n        long sum = 0;\n        while (values.hasNext()) {\n          sum += ((LongWritable) values.next()).get();\n        }\n        // output sum\n        output.collect(key, new LongWritable(sum));\n      } else if (k.startsWith(\"status\") || k.startsWith(\"retry\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scx\")) {\n        LongWritable cnt = new LongWritable(Long.MIN_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() < val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scn\")) {\n        LongWritable cnt = new LongWritable(Long.MAX_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() > val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"sct\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "github_50-250_23_p0.java", :java => "// https://searchcode.com/api/result/99975919/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble avgVol = 0;\n\t\t\tdouble sum = 0;\n\t\t\tdouble count = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tsum += values.next().get();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tavgVol = sum/count;\n\t\t\toutput.collect(key, new DoubleWritable(avgVol));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p7.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum/count ) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_30_p1.java", :java => "// https://searchcode.com/api/result/138792869/\n    public void configure(JobConf job) {}\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n            throws IOException {\n\n      String k = ((Text) key).toString();\n      if (k.equals(\"T\")) {\n        // sum all values for this key\n        long sum = 0;\n        while (values.hasNext()) {\n          sum += ((LongWritable) values.next()).get();\n        }\n        // output sum\n        output.collect(key, new LongWritable(sum));\n      } else if (k.startsWith(\"status\") || k.startsWith(\"retry\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scx\")) {\n        LongWritable cnt = new LongWritable(Long.MIN_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() < val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scn\")) {\n        LongWritable cnt = new LongWritable(Long.MAX_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() > val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"sct\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "bitbucket_250-450_87_p0.java", :java => "// https://searchcode.com/api/result/49661317/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_44_p1.java", :java => "// https://searchcode.com/api/result/65664620/\n\nfloat marginal = 0.0f;\nint need_to_cover = 0;\nFloatWritable prob = new FloatWritable(0.0f);\n\npublic void reduce(Text key, Iterator<IntWritable> values,\n        OutputCollector<Text, FloatWritable> output, \n        Reporter reporter) throws IOException {\n    // if (!values.hasNext()) throw new UnexpectedException(\"no values for \" + key);\n    int v = values.next().get();\n    if (need_to_cover == 0) {\n        // if (key.getE().size() != 0) throw new UnexpectedException(\"Expected empty e-side: \" + key);\n        need_to_cover = v;\n        // if (v < 1) throw new UnexpectedException(\"Bad count: \" + v);\n        marginal = (float)v;\n    } else {\n        // if (key.getE().size() == 0) throw new UnexpectedException(\"unaccounted for counts: \" + need_to_cover + \" key=\" +key);\n        float p = (float)v / marginal;\n        prob.set(p);\n        output.collect(key, prob);\n        need_to_cover -= v;\n    }\t\t\t    \n}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_69_p0.java", :java => "// https://searchcode.com/api/result/107827748/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException \n\t\t{\n\t\t\tint sum = 0;\n\t\t \twhile (values.hasNext()) \n\t\t \t{\n\t\t \t\tsum += values.next().get();\n\t\t \t}\n\t\t \toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_43_p2.java", :java => "// https://searchcode.com/api/result/48924584/\n\t\tint number_nodes = 0;\n\t\tdouble mixing_c = 0;\n\t\tdouble random_coeff = 0;\n\n\t\tpublic void configure(JobConf job) {\n\t\t\tnumber_nodes = Integer.parseInt(job.get(\"number_nodes\"));\n\t\t\tmixing_c = Double.parseDouble(job.get(\"mixing_c\"));\n\t\t\trandom_coeff = (1-mixing_c) / (double)number_nodes;\n\n\t\t\tSystem.out.println(\"RedStage2: number_nodes = \" + number_nodes + \", mixing_c = \" + mixing_c + \", random_coeff = \" + random_coeff );\n\t\t}\n\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i;\n\t\t\tdouble min_value = 1.0;\n\t\t\tdouble max_value = 0.0;\n\n\t\t\tint min_or_max = key.get();\t// 0 : min, 1: max\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_value = values.next().get();\n\n\t\t\t\tif( min_or_max == 0 ) {\t// find min\n\t\t\t\t\tif( cur_value < min_value )\n\t\t\t\t\t\tmin_value = cur_value;\n\t\t\t\t} else {\t\t\t\t// find max\n\t\t\t\t\tif( cur_value > max_value )\n\t\t\t\t\t\tmax_value = cur_value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( min_or_max == 0)\n\t\t\t\toutput.collect( key, new DoubleWritable(min_value) );\n\t\t\telse\n\t\t\t\toutput.collect( key, new DoubleWritable(max_value) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_160_p0.java", :java => "// https://searchcode.com/api/result/36001114/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_44_p0.java", :java => "// https://searchcode.com/api/result/65664620/\nIntWritable res = new IntWritable();\npublic void reduce(Text key, Iterator<IntWritable> values,\n        OutputCollector<Text,IntWritable> output, \n        Reporter reporter) throws IOException {\n    int sum = 0;\n    while (values.hasNext()) {\n        sum += values.next().get();\n    }\n    res.set(sum);\n    output.collect(key, res);\n}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_1_p3.java", :java => "// https://searchcode.com/api/result/87881700/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MAX_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey > lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MAX_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) > 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_187_p0.java", :java => "// https://searchcode.com/api/result/48924593/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i = 0;\n\t\t\tdouble val_double[] = new double[2];\n\t\t\tval_double[0] = 0;\n\t\t\tval_double[1] = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tval_double[i] = values.next().get();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdouble result = val_double[0] + val_double[1];\n\t\t\tif( result != 0 )\n\t\t\t\toutput.collect(key, new DoubleWritable(result));\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_38_p0.java", :java => "// https://searchcode.com/api/result/99975950/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble avgVal = 0;\n\t\t\tint count = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tsum += values.next().get();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tavgVal = sum/count;\n\t\t\toutput.collect(key, new DoubleWritable(avgVal));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_185_p0.java", :java => "// https://searchcode.com/api/result/48924591/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, Text> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i = 0;\n\t\t\tdouble val_double[] = new double[2];\n\t\t\tval_double[0] = 0;\n\t\t\tval_double[1] = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tval_double[i] = values.next().get();\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdouble result = val_double[0] + val_double[1];\n\t\t\tif( result != 0 )\n\t\t\t\toutput.collect(key, new Text(\"v\" + result));\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_0_p1.java", :java => "// https://searchcode.com/api/result/57173764/\npublic void configure(JobConf job) {\n}\n\npublic void reduce(IntWritable key, Iterator<IntWritable> it,\n        OutputCollector<IntWritable, IntWritable> out,\n        Reporter reporter) throws IOException {\n    int keyint = key.get();\n    int count = 0;\n    while (it.hasNext()) {\n        it.next();\n        count++;\n    }\n    out.collect(new IntWritable(keyint), new IntWritable(count));\n}\npublic void close() {\n}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p3.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_0_p0.java", :java => "// https://searchcode.com/api/result/74259923/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_450-650_30_p0.java", :java => "// https://searchcode.com/api/result/138792869/\nLongWritable val = new LongWritable();\n\n// public CrawlDbStatCombiner() { }\npublic void configure(JobConf job) { }\npublic void close() {}\npublic void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n    throws IOException {\n    val.set(0L);\n    String k = ((Text)key).toString();\n    if (!k.equals(\"s\")) {\n        while (values.hasNext()) {\n            LongWritable cnt = (LongWritable)values.next();\n            val.set(val.get() + cnt.get());\n        }\n        output.collect(key, val);\n    } else {\n        long total = 0;\n        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n        while (values.hasNext()) {\n            LongWritable cnt = (LongWritable)values.next();\n            if (cnt.get() < min) min = cnt.get();\n            if (cnt.get() > max) max = cnt.get();\n            total += cnt.get();\n        }\n        output.collect(new Text(\"scn\"), new LongWritable(min));\n        output.collect(new Text(\"scx\"), new LongWritable(max));\n        output.collect(new Text(\"sct\"), new LongWritable(total));\n    }\n}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_47_p1.java", :java => "// https://searchcode.com/api/result/37458351/\n    public void configure(JobConf job) {}\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n            throws IOException {\n\n      String k = ((Text) key).toString();\n      if (k.equals(\"T\")) {\n        // sum all values for this key\n        long sum = 0;\n        while (values.hasNext()) {\n          sum += ((LongWritable) values.next()).get();\n        }\n        // output sum\n        output.collect(key, new LongWritable(sum));\n      } else if (k.startsWith(\"status\") || k.startsWith(\"retry\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scx\")) {\n        LongWritable cnt = new LongWritable(Long.MIN_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() < val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"scn\")) {\n        LongWritable cnt = new LongWritable(Long.MAX_VALUE);\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          if (cnt.get() > val.get()) cnt.set(val.get());\n        }\n        output.collect(key, cnt);\n      } else if (k.equals(\"sct\")) {\n        LongWritable cnt = new LongWritable();\n        while (values.hasNext()) {\n          LongWritable val = (LongWritable)values.next();\n          cnt.set(cnt.get() + val.get());\n        }\n        output.collect(key, cnt);\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "github_50-250_136_p0.java", :java => "// https://searchcode.com/api/result/67848189/\n\t      public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t        int sum = 0;\n\t        while (values.hasNext()) {\n\t          sum += values.next().get();\n\t        }\n\t        output.collect(key, new IntWritable(sum));\n\t      }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_1250-1450_0_p0.java", :java => "// https://searchcode.com/api/result/101728565/\n\n    public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output,\n        Reporter reporter) throws IOException {\n      output.collect(key, values.next());\n    }\n\n    public void configure(JobConf job) {\n\n    }\n\n    public void close() throws IOException {\n\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "bitbucket_450-650_1_p2.java", :java => "// https://searchcode.com/api/result/57173818/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p5.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final Text key, final Iterator<DoubleWritable> values, final OutputCollector<Text, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_10_p0.java", :java => "// https://searchcode.com/api/result/74613535/\n           public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n              int sum = 0;\n              while (values.hasNext()){\n                 sum += values.next().get();\n              }\n              output.collect(key, new IntWritable(sum));\n           }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_549_p0.java", :java => "// https://searchcode.com/api/result/116116657/\n\n// private NcdcStationMetadata metadata;\n\n/*\npublic void configure(JobConf conf) {\n    metadata = new NcdcStationMetadata();\n    try {\n        Path[] localPaths = DistributedCache.getLocalCacheFiles(conf);\n        if (localPaths.length == 0) {\n            throw new FileNotFoundException(\"Distributed cache file not found.\");\n        }\n        File localFile = new File(localPaths[0].toString());\n        metadata.initialize(localFile);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n*/\n\npublic void reduce(Text key, Iterator<IntWritable> values,\n        OutputCollector<Text, IntWritable> output, Reporter reporter)\n    throws IOException {\n\n    //String stationName = metadata.getStationName(key.toString());\n    String stationName = key.toString();\n\n    int maxValue = Integer.MIN_VALUE;\n    while (values.hasNext()) {\n        maxValue = Math.max(maxValue, values.next().get());\n    }\n    output.collect(new Text(stationName), new IntWritable(maxValue));\n}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_110_p0.java", :java => "// https://searchcode.com/api/result/49661222/\n    \n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output, \n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_157_p0.java", :java => "// https://searchcode.com/api/result/137966716/\n    public void reduce(Text key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException\n    {\n      int sum = 0;  \n      while(values.hasNext())\n      {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_31_p2.java", :java => "// https://searchcode.com/api/result/49661307/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_421_p0.java", :java => "// https://searchcode.com/api/result/96939047/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_401_p0.java", :java => "// https://searchcode.com/api/result/93911531/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_1_p0.java", :java => "// https://searchcode.com/api/result/100326488/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_666_p0.java", :java => "// https://searchcode.com/api/result/69347214/\n\n//private static final Logger log = LoggerFactory.getLogger(BayesTfIdfReducer.class);\n\npublic void reduce(Text key,\n        Iterator<DoubleWritable> values,\n        OutputCollector<Text, DoubleWritable> output,\n        Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    if(token.startsWith(\"*vocabCount\")) {\n        double vocabCount = 0.0;\n        while (values.hasNext()) {\n            vocabCount += values.next().get();\n        }\n        //log.info(\"{}\t{}\", token, vocabCount);\n        output.collect(key, new DoubleWritable(vocabCount));\n    } else {\n        double idfTimes_D_ij = 1.0;\n        //int numberofValues = 0;\n        while (values.hasNext()) {\n            idfTimes_D_ij *= values.next().get();\n            //numberofValues ++;\n        }\n        //if(numberofValues!=2) throw new IOException(\"Number of values should be exactly 2\");\n\n        output.collect(key, new DoubleWritable(idfTimes_D_ij));\n    }\n}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_62_p0.java", :java => "// https://searchcode.com/api/result/66419818/\n \n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output, \n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_714_p0.java", :java => "// https://searchcode.com/api/result/8195087/\n\n  public void reduce(Text key, Iterator<LongWritable> values,\n                     OutputCollector<Text, LongWritable> output,\n                     Reporter reporter)\n    throws IOException {\n\n    // sum all values for this key\n    long sum = 0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n\n    // output sum\n    output.collect(key, new LongWritable(sum));\n  }\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_1050-1250_2_p4.java", :java => "// https://searchcode.com/api/result/48924599/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n\t\t{\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\n\t\t\t\tsum += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_3_p2.java", :java => "// https://searchcode.com/api/result/100326448/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_304_p0.java", :java => "// https://searchcode.com/api/result/97674979/\n\t\t\n\t\tpublic void reduce (Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, IntWritable> output, Reporter report)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tcount += values.next().get();\n\t\t\t}\n\t\t\t\n\t\t\toutput.collect(key, new IntWritable(count));\n\t\t\t\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_131_p0.java", :java => "// https://searchcode.com/api/result/65246192/\n    public void reduce( Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n      throws IOException\n    {\n      long sum = 0;\n\n      while ( values.hasNext( ) )\n        {\n          LongWritable value = values.next( );\n          \n          sum += value.get( );\n        }\n      \n      output.collect( key, new LongWritable( sum ) );\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_118_p0.java", :java => "// https://searchcode.com/api/result/100948409/\n\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\t//Reduce side Business Logic\n\t\t}\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_1_p3.java", :java => "// https://searchcode.com/api/result/57173818/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MAX_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey > lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MAX_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) > 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_161_p0.java", :java => "// https://searchcode.com/api/result/46998530/\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            output.collect(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_0_p0.java", :java => "// https://searchcode.com/api/result/102256897/\n\nprivate long numInside = 0;\nprivate long numOutside = 0;\n\n/** Store job configuration. */\npublic void configure(JobConf job) {\n    //conf = job;\n}\n\n/**\n * Accumulate number of points inside/outside results from the mappers.\n * @param isInside Is the points inside? \n * @param values An iterator to a list of point counts\n * @param output dummy, not used here.\n * @param reporter\n */\npublic void reduce(BooleanWritable isInside,\n        Iterator<LongWritable> values,\n        OutputCollector<Text, IntWritable> output,\n        Reporter reporter) throws IOException {\n    if (isInside.get()) {\n        for(; values.hasNext(); numInside += values.next().get());\n    } else {\n        for(; values.hasNext(); numOutside += values.next().get());\n    }\n}\n\n/**\n * Reduce task done, write output to a file.\n */\n/*\npublic void close() throws IOException {\n    //write output to a file\n    Path outDir = new Path(TMP_DIR, \"out\");\n    Path outFile = new Path(outDir, \"reduce-out\");\n    FileSystem fileSys = FileSystem.get(conf);\n    SequenceFile.Writer writer = SequenceFile.createWriter(fileSys, conf,\n            outFile, LongWritable.class, LongWritable.class, \n            CompressionType.NONE);\n    writer.append(new LongWritable(numInside), new LongWritable(numOutside));\n    writer.close();\n}\n*/\n", :t1 => "BooleanWritable", :t2 => "LongWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_135_p0.java", :java => "// https://searchcode.com/api/result/66636679/\n\t       public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext())\n\t\t\t\tsum += values.next().get();\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_9_p3.java", :java => "// https://searchcode.com/api/result/48924579/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_value = values.next().get();\n\t\t\t\tsum += cur_value;\n\t\t\t}\n\n\t\t\toutput.collect( key, new IntWritable(sum) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_30_p1.java", :java => "// https://searchcode.com/api/result/93179565/\n\n\t\tpublic void reduce(IntWritable k, Iterator<IntWritable> v, OutputCollector<IntWritable, IntWritable> out, Reporter r)\n\t\t\t\tthrows IOException {\n\t\t\twhile(v.hasNext()) {\n\t\t\t\tout.collect(new IntWritable(k.get() % 4), v.next());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\n\t\tpublic void close() throws IOException { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_246_p0.java", :java => "// https://searchcode.com/api/result/73390730/\nprivate static int K = 0;\npublic static long HighKmer = 0;\n//private static int OVALSIZE = 0;\nprivate static int All_Kmer = 0;\n\npublic void configure(JobConf job) {\n    K = 24;//Integer.parseInt(job.get(\"K\"));\n    HighKmer = Long.parseLong(job.get(\"UP_KMER\"));\n}\n\npublic void reduce(Text prefix, Iterator<IntWritable> iter,\n        OutputCollector<Text, Text> output, Reporter reporter)\n    throws IOException\n    {\n        int sum =0;\n        //int read_count = 0;\n        List<String> ReadID_list = new ArrayList<String>();\n        //List<String> ReadID_list;\n        //Map<String, List<String>> idx_ReadID_list = new HashMap<String, List<String>>();\n        while(iter.hasNext())\n        {\n            int frequency = iter.next().get();\n            sum = sum + frequency;\n            //\\\n            if (sum > HighKmer) {\n                output.collect(prefix, new Text(\"\"));\n                //output.collect(new Text(Node.rc(prefix.toString())), new Text(\"\"));\n                reporter.incrCounter(\"Brush\", \"hkmer\", 1);\n                return;\n            }\n        }\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_1_p1.java", :java => "// https://searchcode.com/api/result/100326488/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int count = 0;\n      while (it.hasNext()) {\n        it.next();\n        count++;\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(count));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_30_p0.java", :java => "// https://searchcode.com/api/result/93179565/\n\n\t\tpublic void reduce(IntWritable k, Iterator<IntWritable> v, OutputCollector<IntWritable, IntWritable> out, Reporter r)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\twhile(v.hasNext()) {\n\t\t\t\tsum += v.next().get();\n\t\t\t}\n\t\t\tout.collect(k, new IntWritable(sum));\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\n\t\tpublic void close() throws IOException { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_52_p0.java", :java => "// https://searchcode.com/api/result/48925527/\n    LongWritable val = new LongWritable();\n    \n    //public CrawlDbStatCombiner() { }\n    public void configure(JobConf job) { }\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n        throws IOException {\n      val.set(0L);\n      String k = ((Text)key).toString();\n      if (!k.equals(\"s\")) {\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          val.set(val.get() + cnt.get());\n        }\n        output.collect(key, val);\n      } else {\n        long total = 0;\n        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          if (cnt.get() < min) min = cnt.get();\n          if (cnt.get() > max) max = cnt.get();\n          total += cnt.get();\n        }\n        output.collect(new Text(\"scn\"), new LongWritable(min));\n        output.collect(new Text(\"scx\"), new LongWritable(max));\n        output.collect(new Text(\"sct\"), new LongWritable(total));\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_47_p0.java", :java => "// https://searchcode.com/api/result/37458351/\n    LongWritable val = new LongWritable();\n    \n    //public CrawlDbStatCombiner() { }\n    public void configure(JobConf job) { }\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n        throws IOException {\n      val.set(0L);\n      String k = ((Text)key).toString();\n      if (!k.equals(\"s\")) {\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          val.set(val.get() + cnt.get());\n        }\n        output.collect(key, val);\n      } else {\n        long total = 0;\n        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          if (cnt.get() < min) min = cnt.get();\n          if (cnt.get() > max) max = cnt.get();\n          total += cnt.get();\n        }\n        output.collect(new Text(\"scn\"), new LongWritable(min));\n        output.collect(new Text(\"scx\"), new LongWritable(max));\n        output.collect(new Text(\"sct\"), new LongWritable(total));\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_31_p3.java", :java => "// https://searchcode.com/api/result/49661307/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MAX_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey > lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MAX_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) > 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_396_p0.java", :java => "// https://searchcode.com/api/result/93911500/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_663_p0.java", :java => "// https://searchcode.com/api/result/69346937/\n  \n  //private static final Logger log = LoggerFactory.getLogger(CBayesThetaReducer.class);\n  \n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    double weight = 0.0;\n    int numberofValues = 0;\n    while (values.hasNext()) {\n      weight += values.next().get();\n      numberofValues ++;\n    }    \n    if(numberofValues < 2) return;    \n    //if(weight <= 0.0) log.info(\"{}=>{}\", token, weight);\n    output.collect(key, new DoubleWritable(weight));\n  }\n\n \n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_5_p2.java", :java => "// https://searchcode.com/api/result/49661265/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_5_p1.java", :java => "// https://searchcode.com/api/result/49661265/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int count = 0;\n      while (it.hasNext()) {\n        it.next();\n        count++;\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(count));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_321_p0.java", :java => "// https://searchcode.com/api/result/100948388/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values, \n\t\t\t\tOutputCollector<Text, Text> collect, Reporter reporter) \n\t\tthrows IOException { \n\t\t\tlong sum = 0; \n\t\t\tint counter = 0; \n\t\t\twhile(values.hasNext()) \n\t\t\t{ \n\t\t\t\tsum = sum + values.next().get(); \n\t\t\t\tcounter++; \n\t\t\t} \n\t\t\tfloat avg = (float) sum/counter; \n\t\t\tString emitValue = sum + \"\t\" + avg; \n\t\t\tcollect.collect(key, new Text(emitValue));\t\n\t\t} \n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_650-850_9_p2.java", :java => "// https://searchcode.com/api/result/48924579/\n\t\tint number_nodes = 0;\n\t\tdouble mixing_c = 0;\n\t\tdouble random_coeff = 0;\n\n\t\tpublic void configure(JobConf job) {\n\t\t\tnumber_nodes = Integer.parseInt(job.get(\"number_nodes\"));\n\t\t\tmixing_c = Double.parseDouble(job.get(\"mixing_c\"));\n\t\t\trandom_coeff = (1-mixing_c) / (double)number_nodes;\n\n\t\t\tSystem.out.println(\"RedStage2: number_nodes = \" + number_nodes + \", mixing_c = \" + mixing_c + \", random_coeff = \" + random_coeff );\n\t\t}\n\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i;\n\t\t\tdouble min_value = 1.0;\n\t\t\tdouble max_value = 0.0;\n\n\t\t\tint min_or_max = key.get();\t// 0 : min, 1: max\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_value = values.next().get();\n\n\t\t\t\tif( min_or_max == 0 ) {\t// find min\n\t\t\t\t\tif( cur_value < min_value )\n\t\t\t\t\t\tmin_value = cur_value;\n\t\t\t\t} else {\t\t\t\t// find max\n\t\t\t\t\tif( cur_value > max_value )\n\t\t\t\t\t\tmax_value = cur_value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( min_or_max == 0)\n\t\t\t\toutput.collect( key, new DoubleWritable(min_value) );\n\t\t\telse\n\t\t\t\toutput.collect( key, new DoubleWritable(max_value) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_1_p2.java", :java => "// https://searchcode.com/api/result/100326488/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_667_p0.java", :java => "// https://searchcode.com/api/result/69347254/\n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the tfidf of the feature  of times we\'ve seen this label word per local node.  Output is the same\n\n    double sum = 0.0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n    output.collect(key, new DoubleWritable(sum));\n  }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_517_p0.java", :java => "// https://searchcode.com/api/result/93068158/\n\n  public void reduce(Text key, Iterator<LongWritable> values,\n                     OutputCollector<Text, LongWritable> output,\n                     Reporter reporter)\n    throws IOException {\n\n    // sum all values for this key\n    long sum = 0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n\n    // output sum\n    output.collect(key, new LongWritable(sum));\n  }\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_3_p3.java", :java => "// https://searchcode.com/api/result/100326448/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MAX_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey > lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MAX_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) > 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_133_p0.java", :java => "// https://searchcode.com/api/result/65246220/\n    public void reduce( Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n      throws IOException\n    {\n      long sum = 0;\n\n      while ( values.hasNext( ) )\n        {\n          LongWritable value = values.next( );\n          \n          sum += value.get( );\n        }\n      \n      output.collect( key, new LongWritable( sum ) );\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_661_p0.java", :java => "// https://searchcode.com/api/result/69346903/\n\n  // private static final Logger log = LoggerFactory.getLogger(CBayesNormalizedWeightReducer.class);      \n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    double weight = 0.0;\n    while (values.hasNext()) {\n      weight += values.next().get();\n    }\n    if(token.equalsIgnoreCase(\"rec.motorcycles,miller\"))\n      //log.info(\"{}=>{}\", token, weight);\n    output.collect(key, new DoubleWritable(weight));\n  }\n\n \n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_94_p0.java", :java => "// https://searchcode.com/api/result/101728519/\n\n    public void configure(JobConf job) {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void close() throws IOException {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void reduce(Text key, Iterator<IntWritable> values,OutputCollector<Text, IntWritable> output, Reporter reporter)\n        throws IOException {\n      int count = 0;\n      while (values.hasNext()) \n        count += values.next().get();\n      if (count >= 10) { \n        output.collect(key, new IntWritable(count));\n      }\n    } \n    \n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
puts "Benchmarks 2018 done"