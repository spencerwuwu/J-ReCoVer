Testcase.create(:name => "bitbucket2_50-250_197_p0.java", :java => "// https://searchcode.com/api/result/48924593/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i = 0;\n\t\t\tdouble val_double[] = new double[2];\n\t\t\tval_double[0] = 0;\n\t\t\tval_double[1] = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tval_double[i] = values.next().get();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdouble result = val_double[0] + val_double[1];\n\t\t\tif( result != 0 )\n\t\t\t\toutput.collect(key, new DoubleWritable(result));\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample from these testcases. ")
Testcase.create(:name => "github2_50-250_162_p0.java", :java => "// https://searchcode.com/api/result/66797561/\n\t\t\n\t\t/*\n\t\t * This method should calculate the maximum row length for each file \n\t\t */\n\t\tpublic void reduce(Text fileName, Iterable<IntWritable> arg1, Context context) throws IOException ,InterruptedException {\n\t\t\t\n\t\t\t\n\t\t\tint maxValue = Integer.MIN_VALUE;\n\t\t\t\n\t\t\t//TODO: calculate the maximum row length per fileName\n\n\t\t\tcontext.write(fileName, new IntWritable(maxValue));\n\t\t};\n\t\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_450-650_93_p1.java", :java => "// https://searchcode.com/api/result/10576150/\n      \n      public void reduce(BytesWritable key, Iterator<IntWritable> values,\n                         OutputCollector<BytesWritable, IntWritable> output,\n                         Reporter reporter) throws IOException {\n\tIntWritable sortInput = new IntWritable(1);\n\tIntWritable sortOutput = new IntWritable(2);\n        int ones = 0;\n        int twos = 0;\n        while (values.hasNext()) {\n          IntWritable count = values.next(); \n          if (count.equals(sortInput)) {\n            ++ones;\n          } else if (count.equals(sortOutput)) {\n            ++twos;\n          } else {\n            throw new IOException(\"Invalid \'value\' of \" + count.get() + \n                                  \" for (key,value): \" + key.toString());\n          }\n        }\n        \n        // Check to ensure there are equal no. of ones and twos\n        if (ones != twos) {\n          throw new IOException(\"Illegal (\'one\', \'two\'): (\" + ones + \", \" + twos +\n                                \") for (key, value): \" + key.toString());\n        }\n      }\n", :t1 => "BytesWritable", :t2 => "IntWritable", :t3 => "BytesWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p0.java", :java => "// https://searchcode.com/api/result/110747437/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github2_50-250_6_p0.java", :java => "// https://searchcode.com/api/result/93068483/\n    private IntWritable result = new IntWritable();\n  \n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context) throws IOException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_151_p0.java", :java => "// https://searchcode.com/api/result/59025411/\n\t\t/**\n\t\t * Reduce method which implements summation. Acts as both reducer and\n\t\t * combiner.\n\t\t * \n\t\t * @throws IOException\n\t\t */\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\n\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<IntWritable> iterator = values.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tsum += iterator.next().get();\n\t\t\t}\n\t\t\tcontext.write(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_318_p0.java", :java => "// https://searchcode.com/api/result/100948358/\n/*\n\t\tMap<String, String> info = null;\n\t\tpublic void setup(Context context) throws IOException\n        {\n                loadKeys(context);\n        }\n        void loadKeys(Context context) throws IOException\n        {\n                FSDataInputStream in = null;\n                BufferedReader br = null;\n                FileSystem fs = FileSystem.get(context.getConfiguration());\n                Path path = new Path(filePath);\n                in = fs.open(path);\n                br  = new BufferedReader(new InputStreamReader(in));\n                info = new HashMap<String, String>();\n                String line = \"\";\n                while ( (line = br.readLine() )!= null) {\n                String[] arr = line.split(\"\\,\");\n                if (arr.length == 2)\n                \tinfo.put(arr[0], arr[1]);\n                }\n                in.close();\n        }\n\t*/\n        Text kword = new Text();\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\t//String myKey = key.toString() + \"\t\" + info.get(key.toString());\n\t\t\tString myKey = key.toString() + \"\t\";\n\t\t\tkword.set(myKey);\n\t\t\tvword.set(sum);\n\t\t\tcontext.write(kword, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_556_p0.java", :java => "// https://searchcode.com/api/result/65663358/\n/*\n    private TopNScoredObjects<Integer> queue;\n\n    public void setup(Reducer<IntWritable, FloatWritable, IntWritable, FloatWritable>.Context context)\n        throws IOException {\n      int k = context.getConfiguration().getInt(\"n\", 100);\n      queue = new TopNScoredObjects<Integer>(k);\n    }\n    */\n\n    public void reduce(IntWritable nid, Iterable<FloatWritable> iterable, Context context)\n        throws IOException {\n      Iterator<FloatWritable> iter = iterable.iterator();\n      //queue.add(nid.get(), iter.next().get());\n      float f = iter.next().get();\n\n      // Shouldn\'t happen. Throw an exception.\n      if (iter.hasNext()) {\n        //throw new RuntimeException();\n        return;\n      }\n    }\n\n/*\n    public void cleanup(Reducer<IntWritable, FloatWritable, IntWritable, FloatWritable>.Context context)\n        throws IOException, InterruptedException {\n      IntWritable key = new IntWritable();\n      FloatWritable value = new FloatWritable();\n\n      for (PairOfObjectFloat<Integer> pair : queue.extractAll()) {\n        key.set(pair.getLeftElement());\n        value.set(pair.getRightElement());\n        context.write(key, value);\n      }\n    }\n    */\n", :t1 => "IntWritable", :t2 => "FloatWritable", :t3 => "IntWritable", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_1_p2.java", :java => "// https://searchcode.com/api/result/87881700/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_112_p0.java", :java => "// https://searchcode.com/api/result/92069172/\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n        {\n            int sum = 0;\n            for (IntWritable val : values)\n                sum += val.get();\n            context.write(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_312_p0.java", :java => "// https://searchcode.com/api/result/112786286/\n        private Text current = new Text();\n        private int marginalCount = 2;\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n        {\n\t\t/*\n            if (!key.fst.equals(current)) {\n                if (!key.snd.equals(MARGINAL))\n                    return;\n                current.set(key.fst);\n                marginalCount = 0;\n                for (IntWritable x : values)\n                    marginalCount += x.get();\n                return;\n            }\n\t    */\n            // control only gets here if we are using the same marginal\n            int myCount = 0;\n            for (IntWritable x : values)\n                myCount += x.get();\n            context.write(key, new DoubleWritable(myCount / (double) marginalCount));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_151_p0.java", :java => "// https://searchcode.com/api/result/74259363/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_58_p0.java", :java => "// https://searchcode.com/api/result/48927360/\n\n  private int minSupport = 0;\n\n  public void reduce(Text key, Iterable<LongWritable> values, Context context)\n    throws IOException, InterruptedException {\n    long sum = 0;\n    for (LongWritable value : values) {\n      sum += value.get();\n    }\n    if (sum >= minSupport) {\n      context.write(key, new LongWritable(sum));\n    }\n  }\n\n/*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    super.setup(context);\n    minSupport = context.getConfiguration().getInt(DictionaryVectorizer.MIN_SUPPORT,\n                                                   DictionaryVectorizer.DEFAULT_MIN_SUPPORT);\n  }\n\n  */\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_216_p0.java", :java => "// https://searchcode.com/api/result/65663892/\n\t\tprivate final FloatWritable sumWritable = new FloatWritable();\n\n\t\tpublic void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<FloatWritable> iter = values.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tsumWritable.set(sum);\n\t\t\tcontext.write(key, sumWritable);\n\t\t}\n", :t1 => "Text", :t2 => "FloatWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_84_p0.java", :java => "// https://searchcode.com/api/result/119749254/\n\n    // reuse objects\n    private final IntWritable SumValue = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context) \n      throws IOException, InterruptedException {\n\n      // sum up values\n      Iterator<IntWritable> iter = values.iterator();\n      int sum = 0;\n      while (iter.hasNext()) {\n\tsum += iter.next().get();\n      }\n      SumValue.set(sum);\n      context.write(key, SumValue);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_398_p0.java", :java => "// https://searchcode.com/api/result/93911511/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_158_p0.java", :java => "// https://searchcode.com/api/result/140067130/\n\t\tpublic void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile( values.hasNext() ) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect( key, new IntWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_250-450_81_p1.java", :java => "// https://searchcode.com/api/result/93179565/\n\n\t\tpublic void reduce(IntWritable k, Iterator<IntWritable> v, OutputCollector<IntWritable, IntWritable> out, Reporter r)\n\t\t\t\tthrows IOException {\n\t\t\twhile(v.hasNext()) {\n\t\t\t\tout.collect(new IntWritable(k.get() % 4), v.next());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\n\t\tpublic void close() throws IOException { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_650-850_0_p2.java", :java => "// https://searchcode.com/api/result/74259923/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_22_p0.java", :java => "// https://searchcode.com/api/result/99975914/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble stdDev = 0;\n\t\t\tdouble sumSqr = 0;\n\t\t\tdouble count = 0;\n\t\t\tdouble mean = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tdouble value = values.next().get();\n\t\t\t\tsumSqr += value*value;\n\t\t\t\tsum += value;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmean = sum/count;\n\t\t\tstdDev = Math.sqrt((sumSqr-count*mean*mean)/count);\n\t\t\toutput.collect(key, new DoubleWritable(stdDev));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_121_p0.java", :java => "// https://searchcode.com/api/result/100948419/\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\tcontext.write(key, new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_591_p0.java", :java => "// https://searchcode.com/api/result/65662332/\n    private final IntWritable cnt = new IntWritable(1);\n\n    public void reduce(IntWritable key, Iterable<IntWritable> values, Context context)\n        throws IOException, InterruptedException {\n      context.write(key, cnt);\n      cnt.set(cnt.get() + 1);\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_183_p0.java", :java => "// https://searchcode.com/api/result/116093382/\n\n    //private final Log LOG = LogFactory.getLog(LogCombiner.class);\n\n    public void reduce(final Text pKey, final Iterable<IntWritable> pValues, final Context pContext)\n        throws IOException, InterruptedException {\n\n        int count = 0;\n        for (IntWritable val : pValues) {\n            count += val.get();\n        }\n\n        pContext.write(pKey, new IntWritable(count));\n    }\n\n\n    public void close() throws IOException {\n    }\n\n    public void configure(final JobConf job) {\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_183_p1.java", :java => "// https://searchcode.com/api/result/116093382/\n    public void reduce(final Text key, final Iterator<IntWritable> values, final OutputCollector<Text, IntWritable> output,\n                       final Reporter reporter) throws IOException {\n        int count = 0;\n        while (values.hasNext()) {\n            count += values.next().get();\n        }\n\n        output.collect(key, new IntWritable(count));\n    }\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_147_p0.java", :java => "// https://searchcode.com/api/result/10576290/\n    protected final IntWritable one = new IntWritable(1);\n\n    int srcs = 0;\n    \n    /*\n    public void setup(Context context) {\n      srcs = context.getConfiguration().getInt(\"testdatamerge.sources\", 0);\n      assertTrue(\"Invalid src count: \" + srcs, srcs > 0);\n    }\n    */\n\n    public void reduce(IntWritable key, Iterable<IntWritable> values,\n        Context context) throws IOException, InterruptedException {\n      int seen = 0;\n      for (IntWritable value : values) {\n        seen += value.get();\n      }\n      //assertTrue(\"Bad count for \" + key.get(), verify(key.get(), seen));\n      context.write(key, new IntWritable(seen));\n    }\n    \n    //public abstract boolean verify(int key, int occ);\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_58_p0.java", :java => "// https://searchcode.com/api/result/74337136/\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable value : values)\n\t\t\t\tsum += value.get();\n\t\t\tcontext.write(key,new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_586_p0.java", :java => "// https://searchcode.com/api/result/65159880/\n\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context)\n                throws IOException, InterruptedException {\n            int sum = 0;\n            for(IntWritable val: values) {\n                sum += val.get();\n            }\n\n            result.set(sum);\n            context.write(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_132_p0.java", :java => "// https://searchcode.com/api/result/65246202/\n    public void reduce( Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n      throws IOException\n    {\n      long sum = 0;\n\n      while ( values.hasNext( ) )\n        {\n          LongWritable value = values.next( );\n          \n          sum += value.get( );\n        }\n      \n      output.collect( key, new LongWritable( sum ) );\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p6.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final LongWritable key, final Iterator<DoubleWritable> values, final OutputCollector<LongWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "LongWritable", :t2 => "DoubleWritable", :t3 => "LongWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_4_p0.java", :java => "// https://searchcode.com/api/result/74337389/\n\n  public void reduce(LongWritable offset, Iterable<LongWritable> vals,\n                        Context context) throws IOException,\n                                             InterruptedException {\n    // TODO: implement the reduce method\n  }\n  \n", :t1 => "LongWritable", :t2 => "LongWritable", :t3 => "LongWritable", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_650-850_18_p3.java", :java => "// https://searchcode.com/api/result/48924579/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_value = values.next().get();\n\t\t\t\tsum += cur_value;\n\t\t\t}\n\n\t\t\toutput.collect( key, new IntWritable(sum) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_75_p0.java", :java => "// https://searchcode.com/api/result/102256879/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_317_p0.java", :java => "// https://searchcode.com/api/result/100948350/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tcollect.collect(key, new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_27_p0.java", :java => "// https://searchcode.com/api/result/37260181/\n    public void reduce(Text pair, Iterable<DoubleWritable> values, Context ctx)\n      throws IOException, InterruptedException {\n      ctx.write(pair, values.iterator().next());\n    }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_420_p0.java", :java => "// https://searchcode.com/api/result/95819254/\n\t\tprivate IntWritable result = new IntWritable();\n\t\t\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException{\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values){\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n\t\t}\n\t\t\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_320_p0.java", :java => "// https://searchcode.com/api/result/100948377/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, Text> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\tint counter = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tfloat avg = (float) sum/counter;\n\t\t\tString emitValue = sum + \"\t\" + avg;\n\t\t\tcollect.collect(key, new Text(emitValue));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_502_p1.java", :java => "// https://searchcode.com/api/result/2505957/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            Long totalUploadFlow = new Long( 0 );\n            for ( LongWritable val : values ){\n                totalUploadFlow += val.get();\n            }\n            context.write( key, new LongWritable( totalUploadFlow ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p1.java", :java => "// https://searchcode.com/api/result/110747437/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int count = 0;\n      while (it.hasNext()) {\n        it.next();\n        count++;\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(count));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_39_p0.java", :java => "// https://searchcode.com/api/result/133129611/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_94_p0.java", :java => "// https://searchcode.com/api/result/101728519/\n\n    public void configure(JobConf job) {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void close() throws IOException {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void reduce(Text key, Iterator<IntWritable> values,OutputCollector<Text, IntWritable> output, Reporter reporter)\n        throws IOException {\n      int count = 0;\n      while (values.hasNext()) \n        count += values.next().get();\n      if (count >= 10) { \n        output.collect(key, new IntWritable(count));\n      }\n    } \n    \n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_116_p0.java", :java => "// https://searchcode.com/api/result/100948332/\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\t//String country = context.getConfiguration().get(\"country\");\n\t\t\tString country = \"_\";\n\t\t\tString record = country + \": \" + key.toString(); \n\t\t\tcontext.write(new Text(record), new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_178_p0.java", :java => "// https://searchcode.com/api/result/37458208/\n    public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n      long total = 0;\n\n      for (LongWritable val : values) {\n        total += val.get();\n      }\n\n      context.write(new LongWritable(total), key);\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_60_p0.java", :java => "// https://searchcode.com/api/result/94159078/\n        public void reduce(IntWritable key, Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, Reporter reporter) throws IOException {\n            int count = 0;\n            while (values.hasNext()) count += values.next().get();\n            output.collect(key, new IntWritable(count));\n        }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_34_p0.java", :java => "// https://searchcode.com/api/result/94159083/\n        public void reduce( Text key, Iterator<IntWritable> values,\n                            OutputCollector<Text, IntWritable> output,\n                            Reporter reporter) throws IOException\n        {\n            // Iterate over all of the values (counts of occurrences of this word)\n            int count = 0;\n            while( values.hasNext() )\n            {\n                // Add the value to our count\n                count += values.next().get();\n            }\n\n            // Output the word with its count (wrapped in an IntWritable)\n            output.collect( key, new IntWritable( count ) );\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_665_p0.java", :java => "// https://searchcode.com/api/result/69347180/\n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n   \n    double sum = 0.0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n    output.collect(key, new DoubleWritable(sum));\n  }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_98_p0.java", :java => "// https://searchcode.com/api/result/123696322/\n\n    private Text result = new Text();\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context)\tthrows IOException, InterruptedException {\n      int sum = 0;\n      int totalDocs = 1000;\n      for (IntWritable val : values){\n        sum += val.get();\n      }\n      Float idf=new Float(Math.log(totalDocs/sum));\n      result.set(idf.toString());\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_179_p0.java", :java => "// https://searchcode.com/api/result/7193606/\n    \n    /*[*/private NcdcStationMetadata metadata;/*]*/\n    \n    protected void setup(Context context)\n        throws IOException, InterruptedException {\n      metadata = new NcdcStationMetadata();\n      metadata.initialize(new File(\"stations-fixed-width.txt\"));\n    }/*]*/\n\n    public void reduce(Text key, Iterable<IntWritable> values,\n        Context context) throws IOException, InterruptedException {\n      \n      /*[*/String stationName = metadata.getStationName(key.toString());/*]*/\n      \n      int maxValue = Integer.MIN_VALUE;\n      for (IntWritable value : values) {\n        maxValue = Math.max(maxValue, value.get());\n      }\n      context.write(new Text(/*[*/stationName/*]*/), new IntWritable(maxValue));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_582_p0.java", :java => "// https://searchcode.com/api/result/64792685/\n\n    public void reduce(IntWritable key, Iterable<IntWritable> values, Context context)\n        throws IOException, InterruptedException {\n\n        int count = 0;\n        for (IntWritable value : values) {\n            count += value.get();\n        }\n        context.write(key, new IntWritable(count));\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_35_p0.java", :java => "// https://searchcode.com/api/result/95086566/\n\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0; // initialize the sum for each keyword\n      for (IntWritable val : values) {\n        sum += val.get();  \n      }\n      result.set(sum);\n\n      context.write(key, result); // create a pair <keyword, number of occurences>\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_450-650_48_p2.java", :java => "// https://searchcode.com/api/result/48924584/\n\t\tint number_nodes = 0;\n\t\tdouble mixing_c = 0;\n\t\tdouble random_coeff = 0;\n\n\t\tpublic void configure(JobConf job) {\n\t\t\tnumber_nodes = Integer.parseInt(job.get(\"number_nodes\"));\n\t\t\tmixing_c = Double.parseDouble(job.get(\"mixing_c\"));\n\t\t\trandom_coeff = (1-mixing_c) / (double)number_nodes;\n\n\t\t\tSystem.out.println(\"RedStage2: number_nodes = \" + number_nodes + \", mixing_c = \" + mixing_c + \", random_coeff = \" + random_coeff );\n\t\t}\n\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i;\n\t\t\tdouble min_value = 1.0;\n\t\t\tdouble max_value = 0.0;\n\n\t\t\tint min_or_max = key.get();\t// 0 : min, 1: max\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_value = values.next().get();\n\n\t\t\t\tif( min_or_max == 0 ) {\t// find min\n\t\t\t\t\tif( cur_value < min_value )\n\t\t\t\t\t\tmin_value = cur_value;\n\t\t\t\t} else {\t\t\t\t// find max\n\t\t\t\t\tif( cur_value > max_value )\n\t\t\t\t\t\tmax_value = cur_value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( min_or_max == 0)\n\t\t\t\toutput.collect( key, new DoubleWritable(min_value) );\n\t\t\telse\n\t\t\t\toutput.collect( key, new DoubleWritable(max_value) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_679_p0.java", :java => "// https://searchcode.com/api/result/2505958/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            ArrayList<Long> outputFlowArray = new ArrayList<Long>();\n            for ( LongWritable val : values ){\n                outputFlowArray.add( val.get() );\n            }\n            Long totalOutput = Collections.max( outputFlowArray ) - Collections.min( outputFlowArray );\n            String reduceInputKey = key.toString();\n            String[] item = reduceInputKey.split( \",\" );\n            String date = item[0];\n            String macAdd = item[1];\n            String apID = item[2];\n            String outputKey = date + \",\" + macAdd;\n            context.write( new Text( outputKey ), new LongWritable( totalOutput ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_64_p1.java", :java => "// https://searchcode.com/api/result/48924600/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(count) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_450-650_33_p4.java", :java => "// https://searchcode.com/api/result/48924602/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\tIntWritable count_int = new IntWritable(count);\n\t\t\toutput.collect(key, count_int );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_22_p0.java", :java => "// https://searchcode.com/api/result/102256889/\n    private DoubleWritable result = new DoubleWritable();\n\n    public void reduce(IntWritable key, Iterable<DoubleWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n      double sum = 0.0;\n      //byte[] dataArray = new byte[8];\n      for (DoubleWritable val : values) {\n    \t  \n    \t  sum = Math.max(sum,val.get());\n        //val.get();\n      }\n      System.out.println(\"Result of reduce is \"+sum);\n      //EndianUtils.writeSwappedDouble(dataArray, 0, sum);\n      result.set(sum);\n      //result.set(sum);\n      context.write(new IntWritable(1), result);\n    }\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_256_p0.java", :java => "// https://searchcode.com/api/result/74993295/\n\n        public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n                throws IOException {\n            long total = 0;\n            while (values.hasNext()) {\n                total += values.next().get();\n                //output.collect(key, values.next());\n            }\n            output.collect(key, new LongWritable(total));\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_88_p0.java", :java => "// https://searchcode.com/api/result/94576486/\n\n    private IntWritable result = new IntWritable();\n    public void reduce(Text key, Iterable<IntWritable> values,\n      Context context)\n    throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_615_p0.java", :java => "// https://searchcode.com/api/result/67785637/\n\n        private final IntWritable result = new IntWritable();\n\n        public void reduce( Text key, Iterable<IntWritable> values, Context context )\n                throws IOException, InterruptedException{\n\n            int sum = 0;\n            for ( final IntWritable val : values ){\n                sum += val.get();\n            }\n            result.set( sum );\n            context.write( key, result );\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_450-650_155_p0.java", :java => "// https://searchcode.com/api/result/37458351/\n    LongWritable val = new LongWritable();\n    \n    //public CrawlDbStatCombiner() { }\n    public void configure(JobConf job) { }\n    public void close() {}\n    public void reduce(Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n        throws IOException {\n      val.set(0L);\n      String k = ((Text)key).toString();\n      if (!k.equals(\"s\")) {\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          val.set(val.get() + cnt.get());\n        }\n        output.collect(key, val);\n      } else {\n        long total = 0;\n        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n        while (values.hasNext()) {\n          LongWritable cnt = (LongWritable)values.next();\n          if (cnt.get() < min) min = cnt.get();\n          if (cnt.get() > max) max = cnt.get();\n          total += cnt.get();\n        }\n        output.collect(new Text(\"scn\"), new LongWritable(min));\n        output.collect(new Text(\"scx\"), new LongWritable(max));\n        output.collect(new Text(\"sct\"), new LongWritable(total));\n      }\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "bitbucket2_50-250_32_p0.java", :java => "// https://searchcode.com/api/result/48927938/\n    public void reduce(Text pair, Iterable<DoubleWritable> values, Context ctx)\n        throws IOException, InterruptedException {\n      ctx.write(pair, values.iterator().next());\n    }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_614_p0.java", :java => "// https://searchcode.com/api/result/67785625/\n        private final IntWritable result = new IntWritable();    \t\n\n        public void reduce( Text key, Iterable<IntWritable> values, Context context )\n                throws IOException, InterruptedException\n        {\n\n            int sum = 0;\n            for ( final IntWritable val : values )\n            {\n                sum += val.get();\n            }\n            result.set( sum );\n            context.write( key, result );\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_2_p0.java", :java => "// https://searchcode.com/api/result/59415666/\n\tprivate long n = 0;\n\t\n\t/** Reducer setup */\n\t/*\n\tpublic void setup (Context context) {\n\t\t//Get the value of n from the job configuration\n\t\tn = context.getConfiguration().getLong(\"n\", 0);\n\t}\n\t*/\n\n\t\n    public void reduce(LongWritable key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n    \tLongWritable new_key = new LongWritable(0);\n    \tLongWritable new_value = new LongWritable(0);\n    \t\n    \t//TODO: Define the REDUCE function\n    \t\n    \tfor(LongWritable value : values){\n    \t\t\n\t\t//define content of reduce\n\n        \tcontext.write(new_key, new_value);\n\n    \t}\n    }\n", :t1 => "LongWritable", :t2 => "LongWritable", :t3 => "LongWritable", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_215_p0.java", :java => "// https://searchcode.com/api/result/65663884/\n\t\tprivate final FloatWritable sumWritable = new FloatWritable();\n\n\t\tpublic void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<FloatWritable> iter = values.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tsumWritable.set(sum);\n\t\t\tcontext.write(key, sumWritable);\n\t\t}\n", :t1 => "Text", :t2 => "FloatWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_4_p0.java", :java => "// https://searchcode.com/api/result/100327042/\n    \n    public void reduce(IntWritable key, Iterable<IntWritable> it,\n        Context context) throws IOException, InterruptedException {\n      for (IntWritable iw : it) {\n        context.write(iw, null);\n      }\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_120_p0.java", :java => "// https://searchcode.com/api/result/100948413/\n\t\t\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\t//Reduce side Business Logic\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_30_p0.java", :java => "// https://searchcode.com/api/result/92967685/\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context)\n      throws IOException, InterruptedException {\n\n      int sum = 0;\n      for (IntWritable val: values)\n        sum += val.get();\n      context.write(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_446_p0.java", :java => "// https://searchcode.com/api/result/100948399/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0L;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tvword.set(sum);\n\t\t\tcollector.collect(key, vword);\n\t\t}\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_46_p0.java", :java => "// https://searchcode.com/api/result/74337084/\n\n\t\tpublic void reduce(Text text, Iterable<IntWritable> iterable, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\t\n\t\t\tint result = 0;\n\t\t\t\n\t\t\tfor (IntWritable iterator : iterable)\n\t\t\t\tresult += iterator.get();\n\t\t\t\n\t\t\tcontext.write(text, new IntWritable(result));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_248_p0.java", :java => "// https://searchcode.com/api/result/73507140/\n      private IntWritable result = new IntWritable();\n      \n      public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException \n      {\n         int sum = 0; \n         for(IntWritable value : values) {\n            sum += value.get();\n         }\n         result.set(sum);\n         context.write(key, result);\n      }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_436_p0.java", :java => "// https://searchcode.com/api/result/100948353/\n\t\tFloatWritable vword = new FloatWritable();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tfloat ratingAvg = 0.0f;\n\t\t\tlong sum = 0;\n\t\t\tint counter = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tcounter++;\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\tratingAvg = (float) (sum / counter);\n\t\t\tvword.set(ratingAvg);\n\t\t\tcontext.write(key, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_722_p0.java", :java => "// https://searchcode.com/api/result/59024055/\n        private IntWritable result = new IntWritable();\n        public void reduce(Text key, Iterable<IntWritable> values, \n                Context context\n        ) throws IOException, InterruptedException {\n            int sum = 0;\n            for (IntWritable val : values) {\n                sum += val.get();\n            }\n            result.set(sum);\n            context.write(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_152_p0.java", :java => "// https://searchcode.com/api/result/49663142/\n\n     public void reduce(Text key, Iterator<IntWritable> values,\n                        OutputCollector<Text, IntWritable> output,\n                        Reporter reporter) throws IOException {\n       int sum = 0;\n       while (values.hasNext()) {\n         sum += values.next().get();\n       }\n       output.collect(key, new IntWritable(sum));\n     }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_578_p0.java", :java => "// https://searchcode.com/api/result/64321964/\n    LongWritable longWritable = new LongWritable(0);\n\n    public void reduce(Text key, Iterator<LongWritable> values,\n                       OutputCollector<Text, LongWritable> collector,\n                       Reporter reporter) throws IOException {\n\n      long total = 0;\n      while (values.hasNext()) {\n        total += values.next().get();\n      }\n\n      longWritable.set(total);\n      collector.collect(key, longWritable);\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_196_p0.java", :java => "// https://searchcode.com/api/result/48924591/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, Text> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i = 0;\n\t\t\tdouble val_double[] = new double[2];\n\t\t\tval_double[0] = 0;\n\t\t\tval_double[1] = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tval_double[i] = values.next().get();\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdouble result = val_double[0] + val_double[1];\n\t\t\tif( result != 0 )\n\t\t\t\toutput.collect(key, new Text(\"v\" + result));\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample from these testcases. ")
Testcase.create(:name => "github_50-250_520_p0.java", :java => "// https://searchcode.com/api/result/98860640/\n\n\t//private final Log _log = LogFactory.getLog(SsReducer.class);\n\t\n\tpublic void reduce(Text key, Iterable<DoubleWritable> values, Context context) throws IOException, InterruptedException {\n\t\tText k = new Text(key.toString());\n\t\tint count = 0;\n\t\t\n\t\tIterator<DoubleWritable> it = values.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tText v = new Text(it.next().toString());\n\t\t\tcontext.write(k, v);\n\t\t\t//_log.debug(k.toString() + \" => \" + v.toString());\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t//_log.debug(\"count = \" + count);\n\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_502_p0.java", :java => "// https://searchcode.com/api/result/2505957/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            ArrayList<Long> outputFlowArray = new ArrayList<Long>();\n            for ( LongWritable val : values ){\n                outputFlowArray.add( val.get() );\n            }\n            Long totalOutput = Collections.max( outputFlowArray ) - Collections.min( outputFlowArray );\n            String combinerInputKey = key.toString();\n            String[] item = combinerInputKey.split( \",\" );\n            String date = item[0];\n            String macAdd = item[1];\n            String outputKey = date + \",\" + macAdd;\n            context.write( new Text( outputKey ), new LongWritable( totalOutput ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_42_p0.java", :java => "// https://searchcode.com/api/result/121693720/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t            //if (key.toString().equals(\"Haze\")) {\n\t                int sum = 0;\n\t                while (values.hasNext()) {\n\t                    sum += values.next().get();\n\t                }\n\t                output.collect(key, new IntWritable(sum));\n\t            //}\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_119_p0.java", :java => "// https://searchcode.com/api/result/68682372/\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n            //int delay = context.getConfiguration().getInt(DELAY, DEFAULT_DELAY);\n            int sum = 0;\n\t    int j = 0;\n            for (IntWritable i: values){\n                sum += i.get();\n\t\t/*\n                if (k * KEY_NUMBER < j){\n                    Thread.sleep(delay * 1000);\n                    k++;\n                }\n\t\t*/\n                j+=i.get();\n                \n            }\n//            Thread.sleep(3 + sum / delay);\n            context.write(key, new IntWritable(sum));\n        }\n\n/*\n        protected void cleanup(Context context) throws IOException, InterruptedException {\n            super.cleanup(context);\n            FileSystem fs = FileSystem.get(context.getConfiguration());\n            \n            Path p = new Path(new Path(WORKING_DIR, context.getJobName()), COMPARISON_DIR);\n            Path w = new Path(p, context.getJobID().toString());\n            FSDataOutputStream out = fs.create(new Path(new Path(w, \"a\"), getMachineName()));\n            out.writeInt(j);\n            out.close();\n\n        }\n\t*/\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_63_p1.java", :java => "// https://searchcode.com/api/result/48924589/\n\t\tpublic void reduce (final LongWritable key, final Iterator<DoubleWritable> values, final OutputCollector<LongWritable, Text> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i;\n\t\t\tdouble next_rank = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tString cur_value_str = values.next().toString();\n\t\t\t\tnext_rank += Double.parseDouble( cur_value_str ) ;\n\t\t\t}\n\n\t\t\toutput.collect( key, new Text( \"v\" + next_rank ) );\n\t\t}\n", :t1 => "LongWritable", :t2 => "DoubleWritable", :t3 => "LongWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_234_p0.java", :java => "// https://searchcode.com/api/result/141425069/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values,\n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n      //context.progress();\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_211_p0.java", :java => "// https://searchcode.com/api/result/110743700/\n\n  public void reduce(Text key, Iterator<LongWritable> values,\n                     OutputCollector<Text, LongWritable> output,\n                     Reporter reporter)\n    throws IOException {\n\n    // sum all values for this key\n    long sum = 0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n\n    // output sum\n    output.collect(key, new LongWritable(sum));\n  }\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_41_p4.java", :java => "// https://searchcode.com/api/result/48924603/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\t\t\t\tcount += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(count) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_169_p0.java", :java => "// https://searchcode.com/api/result/67105467/\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n      // do nothing for empty keys\n      //if(key.getLength() == 0)\n        //return;\n\n      // otherwise sump up the values\n      int sum = 0;\n      for (IntWritable value : values) {\n        sum += value.get();\n      }\n      context.write(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_93_p0.java", :java => "// https://searchcode.com/api/result/123156380/\n\n    private Text result = new Text();\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context)\tthrows IOException, InterruptedException {\n      int sum = 0;\n      int totalDocs = 4076*2;\n      for (IntWritable val : values){\n        sum += val.get();\n      }\n      Float idf=new Float(Math.log(totalDocs/sum));\n      result.set(idf.toString());\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_50_p0.java", :java => "// https://searchcode.com/api/result/49662007/\n    \n    private long numInside = 0;\n    private long numOutside = 0;\n      \n    /** Store job configuration. */\n    /*\n    public void configure(JobConf job) {\n      conf = job;\n    }\n    */\n\n    /**\n     * Accumulate number of points inside/outside results from the mappers.\n     * @param isInside Is the points inside? \n     * @param values An iterator to a list of point counts\n     * @param output dummy, not used here.\n     * @param reporter\n     */\n    public void reduce(BooleanWritable isInside,\n                       Iterator<LongWritable> values,\n                       OutputCollector<Text, LongWritable> output,\n                       Reporter reporter) throws IOException {\n      if (isInside.get()) {\n        for(; values.hasNext(); numInside += values.next().get());\n      } else {\n        for(; values.hasNext(); numOutside += values.next().get());\n      }\n    }\n\n    /**\n     * Reduce task done, write output to a file.\n     */\n/*\n    public void close() throws IOException {\n      //write output to a file\n      Path outDir = new Path(TMP_DIR, \"out\");\n      Path outFile = new Path(outDir, \"reduce-out\");\n      FileSystem fileSys = FileSystem.get(conf);\n      SequenceFile.Writer writer = SequenceFile.createWriter(fileSys, conf,\n          outFile, LongWritable.class, LongWritable.class, \n          CompressionType.NONE);\n      writer.append(new LongWritable(numInside), new LongWritable(numOutside));\n      writer.close();\n    }\n    */\n", :t1 => "BooleanWritable", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "github_50-250_604_p0.java", :java => "// https://searchcode.com/api/result/65663873/\n\n\t\t// Reuse objects\n\t\tprivate final IntWritable sumWritable = new IntWritable();\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\tthrows IOException, InterruptedException {\n\t\t\t// sum up values\n\t\t\tint sum = 0;\n\t\t\tIterator<IntWritable> iter = values.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tsumWritable.set(sum);\n\t\t\tcontext.write(key, sumWritable);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_152_p0.java", :java => "// https://searchcode.com/api/result/74993087/\n      public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n      {\n          int sum = 0;\n          for (IntWritable val : values)\n              sum += val.get();\n          context.write(key, new IntWritable(sum));\n      }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_136_p0.java", :java => "// https://searchcode.com/api/result/70192096/\n\n        public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n\n            long sum = 0;\n            for (LongWritable value : values) {\n                sum += value.get();\n            }\n            context.write(key, new LongWritable(sum));\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_98_p0.java", :java => "// https://searchcode.com/api/result/95034441/\n\n\t\tNullWritable nullKey =NullWritable.get();\n\t\t\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values,Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<IntWritable> it = values.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tsum += it.next().get();\n\t\t\t}\n\t\t\tcontext.write(nullKey, new Text(key.toString().replace(\":\", \",\") + \",\" + sum));\n\t\t}\n\t\t\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_444_p0.java", :java => "// https://searchcode.com/api/result/100948394/\n      public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n      {\n        long sum = 0;\n        for(LongWritable value : values)\n        {\n            sum = sum + value.get();\n        }\n        context.write(key, new LongWritable(sum));\n      }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_223_p0.java", :java => "// https://searchcode.com/api/result/93179613/\n\n\t\tpublic void reduce(Text k, Iterator<LongWritable> vs, OutputCollector<Text, LongWritable> out, Reporter rep)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tlong cnt = 0;\n\t\t\twhile(vs.hasNext()) {\n\t\t\t\tcnt += vs.next().get();\n\t\t\t}\n\t\t\tout.collect(k, new LongWritable(cnt));\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\t\t\n\t\tpublic void close() throws IOException { }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_37_p0.java", :java => "// https://searchcode.com/api/result/49661290/\n  private IntWritable result = new IntWritable();\n  \n  public void reduce(Text key, Iterable<IntWritable> values, \n                     Context context) throws IOException, InterruptedException {\n    int sum = 0;\n    for (IntWritable val : values) {\n      sum += val.get();\n    }\n    result.set(sum);\n    context.write(key, result);\n  }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_64_p0.java", :java => "// https://searchcode.com/api/result/48924600/\n\t\tprivate final IntWritable one_int = new IntWritable(1);\n\n\t\tint deg_type = 0;\n\t\tint InDeg = 1, OutDeg = 2, InOutDeg = 3;\n\n\t\tpublic void configure(JobConf job) {\n\t\t\tdeg_type = Integer.parseInt(job.get(\"deg_type\"));\n\n\t\t\tSystem.out.println(\"RedPass1 : configure is called. degtype = \" + deg_type );\n\t\t}\n\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint degree = 0;\n\n\t\t\tif( deg_type != InOutDeg) {\n\t\t\t\twhile (values.hasNext()) {\n\t\t\t\t\tint cur_degree = values.next().get();\n\t\t\t\t\tdegree += cur_degree;\n\t\t\t\t}\n\n\t\t\t\toutput.collect(key, new IntWritable(degree) );\n\t\t\t} else { // deg_type == InOutDeg\n\t\t\t\tSet<Integer> outEdgeSet = new TreeSet<Integer>();\n\t\t\t\twhile (values.hasNext()) {\n\t\t\t\t\tint cur_outedge = values.next().get();\n\t\t\t\t\toutEdgeSet.add( cur_outedge );\n\t\t\t\t}\n\n\t\t\t\toutput.collect(key, new IntWritable(outEdgeSet.size()) );\n\t\t\t}\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_116_p0.java", :java => "// https://searchcode.com/api/result/114634378/\n    public void reduce(DoubleWritable key, Iterable<DoubleWritable> ratingAndEstimate, Context ctx)\n        throws IOException, InterruptedException {\n\n      double error = Double.NaN;\n      boolean bothFound = false;\n      for (DoubleWritable ratingOrEstimate : ratingAndEstimate) {\n        if (Double.isNaN(error)) {\n          error = ratingOrEstimate.get();\n        } else {\n          error -= ratingOrEstimate.get();\n          bothFound = true;\n          break;\n        }\n      }\n\n      if (bothFound) {\n        ctx.write(new DoubleWritable(error), NullWritable.get());\n      }\n    }\n", :t1 => "DoubleWritable", :t2 => "DoubleWritable", :t3 => "DoubleWritable", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "bitbucket_50-250_166_p0.java", :java => "// https://searchcode.com/api/result/49661309/\n  \n    int numSeen;\n    int actualSum;\n    public void configure(JobConf job) { }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> val,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      actualSum += key.get(); // keep the running count of the seen values\n      numSeen++; // number of values seen so far\n      \n      // using \'1+2+3+...n =  n*(n+1)/2\' to validate\n      int expectedSum = numSeen * (numSeen + 1) / 2;\n      if (expectedSum != actualSum) {\n        throw new IOException(\"Collect test failed!! Ordering mismatch.\");\n      }\n    }\n\n    public void close() { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_244_p0.java", :java => "// https://searchcode.com/api/result/73390634/\n        private long KmerThreshold = 1 ;\n        private int K = 1;\n        private long Readlen = 36;\n\t\tpublic void configure(JobConf job) {     \n            Readlen = Long.parseLong(job.get(\"READLENGTH\"));\n\t\t}\n        \n\t\tpublic void reduce(Text prefix, Iterator<IntWritable> iter,\n\t\t\t\t\t\t   OutputCollector<Text, IntWritable> output, Reporter reporter)\n\t\t\t\t\t\t   throws IOException\n\t\t{\n            int sum =0;\n            int untrust_count = 0;\n            int TRUST = 1;\n            while(iter.hasNext())\n\t\t\t{\n                int frequency = iter.next().get();\n                if (frequency <= KmerThreshold) {\n                    untrust_count = untrust_count + 1;\n                    TRUST = 0;\n                    break;\n                }\n            }\n            \n            output.collect(prefix, new IntWritable(TRUST));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_162_p0.java", :java => "// https://searchcode.com/api/result/46998531/\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            output.collect(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_435_p0.java", :java => "// https://searchcode.com/api/result/100948347/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0L;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tvword.set(sum);\n\t\t\tcollector.collect(key, vword);\n\t\t}\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_300_p0.java", :java => "// https://searchcode.com/api/result/95819261/\n\t\t\n\t\tprivate LongWritable result = new LongWritable();\n\t\t\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException{\n\t\t\tint sum = 0;\n\t\t\tfor (LongWritable val : values){\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n\t\t}\n\t\t\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_661_p0.java", :java => "// https://searchcode.com/api/result/69346903/\n\n  //private final Logger log = LoggerFactory.getLogger(CBayesNormalizedWeightReducer.class);      \n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    double weight = 0.0;\n    while (values.hasNext()) {\n      weight += values.next().get();\n    }\n    //if(token.equalsIgnoreCase(\"rec.motorcycles,miller\"))\n      //log.info(\"{}=>{}\", token, weight);\n    output.collect(key, new DoubleWritable(weight));\n  }\n\n \n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_250-450_62_p0.java", :java => "// https://searchcode.com/api/result/46344310/\n\n        public void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text,IntWritable> output , Reporter reporter ) \n            throws IOException {\n\n            int sum = 0;\n            while ( values.hasNext() ) {\n                sum += values.next().get();\n            }\n            output.collect( key , new IntWritable( sum ) );\n        }\n\n        public void configure(JobConf job) {}\n        public void close(){}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_116_p0.java", :java => "// https://searchcode.com/api/result/54362944/\n\n\t\tprivate Text outValue = new Text();\n\t\t\n\t\tpublic void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n\n\t\t\tfor (FloatWritable val : values) {\n\n\t\t\t\t//outValue.set(val.toString());\n\t\t\t\t//context.write(key, outValue);\n\t\t\t\tcontext.write(key, val);\n\t\t\t}\n\t\t}\n", :t1 => "Text", :t2 => "FloatWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_39_p0.java", :java => "// https://searchcode.com/api/result/99975954/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint maxTemp = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tint nextTemp = values.next().get();\n\t\t\t\tif (nextTemp > maxTemp)\n\t\t\t\t\tmaxTemp = nextTemp;\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(maxTemp));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_89_p0.java", :java => "// https://searchcode.com/api/result/93246120/\n\t\t\n\t\tprivate IntWritable total = new IntWritable();\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n\t  \n\t  \tint sum = 0;\n\t  \tfor (IntWritable val : values) {\n\t    \tsum += val.get();\n\t  \t}\n\t  \ttotal.set(sum);\n\t  \tcontext.write(key,total);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_4_p2.java", :java => "// https://searchcode.com/api/result/100327042/\n    public void reduce(IntWritable key, Iterable<IntWritable> it,\n        Context context) throws IOException, InterruptedException {\n      int keyint = key.get();\n      int total = 0;\n      Iterator<IntWritable> iter = it.iterator();\n      while (iter.hasNext()) {\n        total += iter.next().get();\n      }\n      context.write(new IntWritable(keyint), new IntWritable(total));\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_599_p0.java", :java => "// https://searchcode.com/api/result/65663644/\n\t\tprivate final IntWritable SumValue = new IntWritable();\n\n\t\tpublic void reduce(Text tupleKey, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tIterator<IntWritable> iter = values.iterator();\n\t\t\t// sum values\n\t\t\tint sum = 0;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\n\t\t\t// keep original tuple key, emit sum of counts as value\n\t\t\tSumValue.set(sum);\n\t\t\tcontext.write(tupleKey, SumValue);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_23_p0.java", :java => "// https://searchcode.com/api/result/99975919/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble avgVol = 0;\n\t\t\tdouble sum = 0;\n\t\t\tdouble count = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tsum += values.next().get();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tavgVol = sum/count;\n\t\t\toutput.collect(key, new DoubleWritable(avgVol));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_153_p0.java", :java => "// https://searchcode.com/api/result/113125449/\n    public void reduce(Text key, Iterable<IntWritable> values, Context ctx)\n        throws IOException, InterruptedException {\n      // IMPLEMENT ME\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p7.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\t\t\tint count = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum/count ) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_4_p1.java", :java => "// https://searchcode.com/api/result/100327042/\n    public void reduce(IntWritable key, Iterable<IntWritable> it,\n        Context context) throws IOException, InterruptedException {\n      int keyint = key.get();\n      int count = 0;\n      for (IntWritable iw : it) {\n        count++;\n      }\n      context.write(new IntWritable(keyint), new IntWritable(count));\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_698_p0.java", :java => "// https://searchcode.com/api/result/10576380/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n        Context context\n        ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_178_p1.java", :java => "// https://searchcode.com/api/result/37458208/\n    public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n      long total = 0;\n\n      for (LongWritable val : values) {\n        total += val.get();\n      }\n      context.write(key, new LongWritable(total));\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_588_p0.java", :java => "// https://searchcode.com/api/result/65662189/\n    private final IntWritable cnt = new IntWritable(1);\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context)\n        throws IOException, InterruptedException {\n      context.write(key, cnt);\n      cnt.set(cnt.get() + 1);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_44_p1.java", :java => "// https://searchcode.com/api/result/65664620/\n\t\t\t    \n\t\tfloat marginal = 1.0f;\n\t\tint need_to_cover = 1;\n\t\tFloatWritable prob = new FloatWritable(0.0f);\n\t\t\t  \n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, FloatWritable> output, \n\t\t\t\tReporter reporter) throws IOException {\n\t\t\t//if (!values.hasNext())\n\t\t\t\t//throw new UnexpectedException(\"no values for \" + key);\n\t\t\tint v = values.next().get();\n\t\t\tif (need_to_cover == 0) {\n\t\t\t\t/*\n\t\t\t\tif (key.getE().size() != 0)\n\t\t\t\t\tthrow new UnexpectedException(\"Expected empty e-side: \" + key);\n\t\t\t\t\t*/\n\t\t\t\tneed_to_cover = v;\n\t\t\t\t/*\n\t\t\t\tif (v < 1)\n\t\t\t\t\tthrow new UnexpectedException(\"Bad count: \" + v);\n\t\t\t\t\t*/\n\t\t\t\tmarginal = (float)v;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\tif (key.getE().size() == 0)\n\t\t\t\t\tthrow new UnexpectedException(\"unaccounted for counts: \" + need_to_cover + \" key=\" +key);\n\t\t\t\t\t*/\n\t\t\t\tfloat p = (float)v / marginal;\n\t\t\t\tprob.set(p);\n\t\t\t\toutput.collect(key, prob);\n\t\t\t\tneed_to_cover -= v;\n\t\t\t}\t\t\t    \n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_69_p0.java", :java => "// https://searchcode.com/api/result/107827748/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException \n\t\t{\n\t\t\tint sum = 0;\n\t\t \twhile (values.hasNext()) \n\t\t \t{\n\t\t \t\tsum += values.next().get();\n\t\t \t}\n\t\t \toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_210_p0.java", :java => "// https://searchcode.com/api/result/2223728/\n\n  private final double LOG_2 = Math.log(2.0);\n\n  private final DoubleWritable result = new DoubleWritable();\n  private long numberItems = 1;\n\n  /*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    super.setup(context);\n    numberItems = Long.parseLong(context.getConfiguration().get(Entropy.NUMBER_ITEMS_PARAM));\n  }\n  */\n\n  public void reduce(Text key, Iterable<DoubleWritable> values, Context context)\n    throws IOException, InterruptedException {\n    double entropy = 0.0;\n    for (DoubleWritable value : values) {\n      entropy += value.get();\n    }\n    result.set((Math.log(numberItems) - entropy / numberItems) / LOG_2);\n    context.write(key, result);\n  }\n\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_600_p0.java", :java => "// https://searchcode.com/api/result/65663676/\n\n\t\t// reuse objects\n\t\tprivate final IntWritable SumValue = new IntWritable();\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values,\n\t\t\t\tContext context) throws IOException, InterruptedException {\n\t\t\t// sum up values\n\t\t\tIterator<IntWritable> iter = values.iterator();\n\t\t\tint sum = 0;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tSumValue.set(sum);\n\t\t\tcontext.write(key, SumValue);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_56_p0.java", :java => "// https://searchcode.com/api/result/48927084/\n  //if true, then output weight\n  private boolean useCounts = true;\n  /**\n   * We can either ignore how many times the user interacted (boolean) or output the number of times they interacted.\n   */\n  public final String USE_COUNTS_PREFERENCE = \"useBooleanPreferences\";\n\n  /*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    useCounts = context.getConfiguration().getBoolean(USE_COUNTS_PREFERENCE, true);\n  }\n  */\n\n  public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n    if (useCounts) {\n      long sum = 0;\n      for (LongWritable value : values) {\n        sum++;\n      }\n      context.write(new Text(key.toString() + \',\' + sum), null);\n    } else {\n      context.write(new Text(key.toString()), null);\n    }\n  }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_188_p0.java", :java => "// https://searchcode.com/api/result/2222777/\n  //if true, then output weight\n  private boolean useCounts = true;\n  /**\n   * We can either ignore how many times the user interacted (boolean) or output the number of times they interacted.\n   */\n  public final String USE_COUNTS_PREFERENCE = \"useBooleanPreferences\";\n\n  /*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    useCounts = context.getConfiguration().getBoolean(USE_COUNTS_PREFERENCE, true);\n  }\n  */\n\n  public void reduce(Text key, Iterable<LongWritable> values, Context context)\n    throws IOException, InterruptedException {\n    if (useCounts) {\n      long sum = 0;\n      for (LongWritable value : values) {\n        sum++;\n      }\n      context.write(new Text(key.toString() + \',\' + sum), null);\n    } else {\n      context.write(new Text(key.toString()), null);\n    }\n  }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_134_p0.java", :java => "// https://searchcode.com/api/result/65409178/\n     public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n\n       int sum = 0;\n       for (IntWritable val : values) {\n         sum += val.get();\n       }\n       context.write(key, new IntWritable(sum));\n     }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_443_p0.java", :java => "// https://searchcode.com/api/result/100948390/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\tvword.set(sum);\n\t\t\tcontext.write(key, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_44_p0.java", :java => "// https://searchcode.com/api/result/65664620/\n\t\tIntWritable res = new IntWritable();\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text,IntWritable> output, \n\t\t\t\tReporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\tres.set(sum);\n\t\t\toutput.collect(key, res);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_1_p3.java", :java => "// https://searchcode.com/api/result/87881700/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MAX_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey > lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MAX_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) > 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_419_p0.java", :java => "// https://searchcode.com/api/result/95819247/\n\t\t\n\t\tprivate IntWritable result = new IntWritable();\n\t\t\t\t\n\t\t\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException{\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (IntWritable val : values){\n\t\t\t\t\t\tsum += val.get();\n\t\t\t\t\t}\n\t\t\t\t\tresult.set(sum);\n\t\t\t\t\tcontext.write(key, result);\n\t\t\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_447_p0.java", :java => "// https://searchcode.com/api/result/100948401/\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong count = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tcount = count + value.get();\n\t\t\t}\n\t\t\tvword.set(count);\n\t\t\tcontext.write(key, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_343_p0.java", :java => "// https://searchcode.com/api/result/65663862/\n\t\tprivate final FloatWritable sumWritable = new FloatWritable();\n\n\t\tpublic void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<FloatWritable> iter = values.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tsumWritable.set(sum);\n\t\t\tcontext.write(key, sumWritable);\n\t\t}\n", :t1 => "Text", :t2 => "FloatWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_247_p0.java", :java => "// https://searchcode.com/api/result/73507136/\n      \n      public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n         int sum = 0;\n         for(IntWritable value : values) {\n            sum += value.get();\n         }\n         context.write(key, new IntWritable(sum));\n      }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_38_p0.java", :java => "// https://searchcode.com/api/result/99975950/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble avgVal = 0;\n\t\t\tint count = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tsum += values.next().get();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tavgVal = sum/count;\n\t\t\toutput.collect(key, new DoubleWritable(avgVal));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_287_p0.java", :java => "// https://searchcode.com/api/result/93911547/\n        private IntWritable v = new IntWritable();\n        private int money = 0;\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n            for (IntWritable line : values) {\n                // System.out.println(key.toString() + \"\t\" + line);\n                money += line.get();\n            }\n            v.set(money);\n            context.write(null, v);\n            System.out.println(\"Output:\" + key + \",\" + money);\n        }\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_19_p0.java", :java => "// https://searchcode.com/api/result/93856032/\n\t\t\n\t\tpublic IntWritable index=new IntWritable(1);\n\t\t\n\t\tpublic void reduce(IntWritable key,Iterable<IntWritable> values,Context context) throws IOException, InterruptedException{\n\t\t\t\n\t\t\tcontext.write(index, key);\n\t\t\tindex=new IntWritable(index.get()+1);\n\t\t\t\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_83_p0.java", :java => "// https://searchcode.com/api/result/48928413/\n\n  private final double LOG_2 = Math.log(2.0);\n\n  private final DoubleWritable result = new DoubleWritable();\n  private long numberItems = 1;\n\n  /*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    super.setup(context);\n    numberItems = Long.parseLong(context.getConfiguration().get(Entropy.NUMBER_ITEMS_PARAM));\n  }\n  */\n\n  public void reduce(Text key, Iterable<DoubleWritable> values, Context context)\n      throws IOException, InterruptedException {\n    double entropy = 0.0;\n    for (DoubleWritable value : values) {\n      entropy += value.get();\n    }\n    result.set((Math.log(numberItems) - entropy / numberItems) / LOG_2);\n    context.write(key, result);\n  }\n\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_581_p0.java", :java => "// https://searchcode.com/api/result/64792661/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      if (sum > 4) {\n        result.set(sum);\n        context.write(key, result);\n      }\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p3.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_608_p0.java", :java => "// https://searchcode.com/api/result/65836069/\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values)\n\t\t\t\tsum += val.get();\n\t\t\tcontext.write(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_52_p0.java", :java => "// https://searchcode.com/api/result/93246129/\n\t\t\n\t\tprivate IntWritable total = new IntWritable();\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n\t\t  \n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values) {\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\ttotal.set(sum);\n\t\t\tcontext.write(key,total);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_44_p0.java", :java => "// https://searchcode.com/api/result/65735664/\n\n        private IntWritable count = new IntWritable();\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context)\n                throws IOException, InterruptedException {\n\n            int sum = 0;\n            for (IntWritable value : values) {\n                sum += value.get();\n            }\n            count.set(sum);\n            context.write(key, count);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_113_p0.java", :java => "// https://searchcode.com/api/result/100852863/\n\t\tprivate IntWritable result = new IntWritable();\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, \n\t\t\t\tContext context\n\t\t) throws IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values) {\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_165_p0.java", :java => "// https://searchcode.com/api/result/48555492/\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException,\n\t\t\t\tInterruptedException {\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values) {\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tcontext.write(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_16_p0.java", :java => "// https://searchcode.com/api/result/93856017/\n\t\t\n\t\tpublic void reduce(Text key,Iterable<IntWritable> values,Context context) throws IOException, InterruptedException{\n\t\t\tint sum=0;\n\t\t\tint count=0;\n\t\t\t\n\t\t\tfor(IntWritable i : values){\n\t\t\t\tsum+=i.get();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcontext.write(key, new IntWritable(sum/count));\n\t\t\t\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_136_p0.java", :java => "// https://searchcode.com/api/result/67848189/\n\t      public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t        int sum = 0;\n\t        while (values.hasNext()) {\n\t          sum += values.next().get();\n\t        }\n\t        output.collect(key, new IntWritable(sum));\n\t      }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_144_p0.java", :java => "// https://searchcode.com/api/result/137334926/\n\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context)\n\tthrows IOException, InterruptedException {\n\n      int sum = 0;\n      for (IntWritable val : values)\n        sum += val.get();\n\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p5.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final Text key, final Iterator<DoubleWritable> values, final OutputCollector<Text, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_10_p0.java", :java => "// https://searchcode.com/api/result/74613535/\n           public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n              int sum = 0;\n              while (values.hasNext()){\n                 sum += values.next().get();\n              }\n              output.collect(key, new IntWritable(sum));\n           }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_601_p0.java", :java => "// https://searchcode.com/api/result/65663694/\n\t\tprivate final IntWritable SumValue = new IntWritable();\n\n\t\tpublic void reduce(Text tupleKey, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tIterator<IntWritable> iter = values.iterator();\n\n\t\t\t// sum values\n\t\t\tint sum = 0;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\n\t\t\t// keep original tuple key, emit sum of counts as value\n\t\t\tSumValue.set(sum);\n\t\t\tcontext.write(tupleKey, SumValue);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_549_p0.java", :java => "// https://searchcode.com/api/result/116116657/\n    \n/*\n    private NcdcStationMetadata metadata;\n    \n    public void configure(JobConf conf) {\n      metadata = new NcdcStationMetadata();\n      try {\n        Path[] localPaths = DistributedCache.getLocalCacheFiles(conf);\n        if (localPaths.length == 0) {\n          throw new FileNotFoundException(\"Distributed cache file not found.\");\n        }\n        File localFile = new File(localPaths[0].toString());\n        metadata.initialize(localFile);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    */\n    public void reduce(Text key, Iterator<IntWritable> values,\n        OutputCollector<Text, IntWritable> output, Reporter reporter)\n        throws IOException {\n      \n      //String stationName = metadata.getStationName(key.toString());\n      String stationName = key.toString();\n      \n      int maxValue = Integer.MIN_VALUE;\n      while (values.hasNext()) {\n        maxValue = Math.max(maxValue, values.next().get());\n      }\n      output.collect(new Text(stationName), new IntWritable(maxValue));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_110_p0.java", :java => "// https://searchcode.com/api/result/49661222/\n    \n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output, \n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_157_p0.java", :java => "// https://searchcode.com/api/result/137966716/\n    public void reduce(Text key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException\n    {\n      int sum = 0;  \n      while(values.hasNext())\n      {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_70_p0.java", :java => "// https://searchcode.com/api/result/71063167/\n\n    public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n      long summ = 0;\n      for (LongWritable value : values) {\n        summ += value.get();\n      }\n\n      context.write(key, new LongWritable(summ));\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_666_p0.java", :java => "// https://searchcode.com/api/result/69347214/\n\n  //private final Logger log = LoggerFactory.getLogger(BayesTfIdfReducer.class);\n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    if(token.startsWith(\"*vocabCount\")) {\n      double vocabCount = 0.0;\n      while (values.hasNext()) {\n        vocabCount += values.next().get();\n      }\n      //log.info(\"{}\t{}\", token, vocabCount);\n      output.collect(key, new DoubleWritable(vocabCount));\n    } else {\n      double idfTimes_D_ij = 1.0;\n      //int numberofValues = 0;\n      while (values.hasNext()) {\n        idfTimes_D_ij *= values.next().get();\n        //numberofValues ++;\n      }\n      //if(numberofValues!=2) throw new IOException(\"Number of values should be exactly 2\");\n      \n      output.collect(key, new DoubleWritable(idfTimes_D_ij));\n    }\n  }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "github_50-250_62_p0.java", :java => "// https://searchcode.com/api/result/66419818/\n \n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output, \n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_710_p0.java", :java => "// https://searchcode.com/api/result/2505952/\n    public void reduce(Text pCountryCode,\n                       Iterable<DoubleWritable> pValues,\n                       Context pContext )\n            throws IOException, InterruptedException{\n        double count = 0;\n        double sum = 0;\n        for ( final DoubleWritable value : pValues ){\n            sum += value.get();\n            count++;\n        }\n\n        final double avg = sum / count;\n\n        pContext.write( pCountryCode, new DoubleWritable( avg ) );\n    }\n\n    //private final Log LOG = LogFactory.getLog( WorldDevIndicatorReducer.class );\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_1050-1250_2_p4.java", :java => "// https://searchcode.com/api/result/48924599/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n\t\t{\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_count = values.next().get();\n\n\t\t\t\tsum += cur_count;\n\t\t\t}\n\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_304_p0.java", :java => "// https://searchcode.com/api/result/97674979/\n\t\t\n\t\tpublic void reduce (Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, IntWritable> output, Reporter report)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tcount += values.next().get();\n\t\t\t}\n\t\t\t\n\t\t\toutput.collect(key, new IntWritable(count));\n\t\t\t\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_24_p0.java", :java => "// https://searchcode.com/api/result/96335780/\n\n\t\t/**\n\t\t * Reduce phase: sum up the number of edges of the triangle.\n\t\t * If there are 3 edges, then it is a complete triangle and \n\t\t * we output it.\n\t\t */\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values,\n\t\t\t\tContext context) throws IOException, InterruptedException {\n\t\t\tIterator<LongWritable> iter = values.iterator();\n\t\t\tint sum = 0;\n\t\t\twhile(iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tif(sum == 3) { // Output if it has 3 edges\n\t\t\t\tcontext.write(key, null);\n\t\t\t}\n\t\t}\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_118_p0.java", :java => "// https://searchcode.com/api/result/100948409/\n\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collector, Reporter reporter)\n\t\t\t\tthrows IOException {\n\t\t\t//Reduce side Business Logic\n\t\t}\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_135_p0.java", :java => "// https://searchcode.com/api/result/66636679/\n\t       public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext())\n\t\t\t\tsum += values.next().get();\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_42_p0.java", :java => "// https://searchcode.com/api/result/105853923/\n        public void reduce(Text key, Iterable<IntWritable> values,\n                Context context)\n                throws IOException, InterruptedException {\n            int sum = 0;\n\t    for(IntWritable value : values) {\n                sum += value.get();\n            }\n            context.write(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_8_p0.java", :java => "// https://searchcode.com/api/result/72246150/\n\n    public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n      long sum = 0;\n      for(LongWritable time : values) {\n        sum += time.get();\n      }\n      context.write(key, new LongWritable(sum));\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_503_p0.java", :java => "// https://searchcode.com/api/result/2505959/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            ArrayList<Long> outputFlowArray = new ArrayList<Long>();\n            for ( LongWritable val : values ){\n                outputFlowArray.add( val.get() );\n            }\n            Long totalOutput = Collections.max( outputFlowArray ) - Collections.min( outputFlowArray );\n            context.write( key, new LongWritable( totalOutput ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_148_p0.java", :java => "// https://searchcode.com/api/result/112051853/\n\n  private int minSupport = 0;\n\n  public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n    long sum = 0;\n    for (LongWritable value : values) {\n      sum += value.get();\n    }\n    if (sum >= minSupport) {\n      context.write(key, new LongWritable(sum));\n    }\n  }\n\n/*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    super.setup(context);\n    minSupport = context.getConfiguration().getInt(DictionaryVectorizer.MIN_SUPPORT, DictionaryVectorizer.DEFAULT_MIN_SUPPORT);\n  }\n  */\n\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_30_p0.java", :java => "// https://searchcode.com/api/result/93179565/\n\n\t\tpublic void reduce(IntWritable k, Iterator<IntWritable> v, OutputCollector<IntWritable, IntWritable> out, Reporter r)\n\t\t\t\tthrows IOException {\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\twhile(v.hasNext()) {\n\t\t\t\tsum += v.next().get();\n\t\t\t}\n\t\t\tout.collect(k, new IntWritable(sum));\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\n\t\tpublic void close() throws IOException { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_442_p0.java", :java => "// https://searchcode.com/api/result/100948386/\n\t\tText vword = new Text();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tdouble avg = 0.0;\n\t\t\tint counter = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tavg = (double) sum / counter;\n\t\t\tvword.set(\"sum: \" + sum + \"\tAverage: \" + avg);\n\t\t\tcontext.write(key, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_644_p0.java", :java => "// https://searchcode.com/api/result/65663714/\n\t\tprivate final IntWritable SumValue = new IntWritable();\n\n\t\tpublic void reduce(Text keyIn, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tIterator<IntWritable> iter = values.iterator();\n\t\t\t// sum values\n\t\t\tint sum = 0;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\n\t\t\t// keep original tuple key, emit sum of counts as value\n\t\t\tSumValue.set(sum);\n\t\t\tcontext.write(keyIn, SumValue);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_503_p1.java", :java => "// https://searchcode.com/api/result/2505959/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            Long totalUploadFlow = new Long( 0 );\n            for ( LongWritable val : values )\n                totalUploadFlow += val.get();\n            context.write( key, new LongWritable( totalUploadFlow ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_663_p0.java", :java => "// https://searchcode.com/api/result/69346937/\n  \n  //private final Logger log = LoggerFactory.getLogger(CBayesThetaReducer.class);\n  \n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the number of times we\'ve seen this label word per local node.  Output is the same\n    String token = key.toString();  \n    double weight = 0.0;\n    int numberofValues = 0;\n    while (values.hasNext()) {\n      weight += values.next().get();\n      numberofValues ++;\n    }    \n    if(numberofValues < 2) return;    \n    //if(weight <= 0.0)\n      //log.info(\"{}=>{}\", token, weight);\n    output.collect(key, new DoubleWritable(weight));\n  }\n\n \n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_170_p0.java", :java => "// https://searchcode.com/api/result/40349424/\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context) \n      throws IOException, InterruptedException {\n        int sum = 0;\n        for (IntWritable val : values) {\n            sum += val.get();\n        }\n        context.write(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_719_p0.java", :java => "// https://searchcode.com/api/result/10978380/\n    public void reduce(Text location,\n                       Iterable<IntWritable> sightings,\n                       Context pContext )\n            throws IOException, InterruptedException{\n        int count = 0;\n        for ( final IntWritable v: sightings){\n            //LOG.debug( \"Location: \" + location + \" Value: \" + v );\n            count += v.get();\n        }\n\n        pContext.write( location, new IntWritable( count ) );\n    }\n\n    //private final Log LOG = LogFactory.getLog( UfoSightingsReducer.class );\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_121_p0.java", :java => "// https://searchcode.com/api/result/62412718/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n\t\n\t\n\t\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      \n\t\n\t\tif(sum > 230 && (1 == 1))\n\t\t{\n \t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n    \t}\n\t\n  }\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_321_p0.java", :java => "// https://searchcode.com/api/result/100948388/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values, \n\t\t\t\tOutputCollector<Text, Text> collect, Reporter reporter) \n\t\tthrows IOException { \n\t\t\tlong sum = 0; \n\t\t\tint counter = 0; \n\t\t\twhile(values.hasNext()) \n\t\t\t{ \n\t\t\t\tsum = sum + values.next().get(); \n\t\t\t\tcounter++; \n\t\t\t} \n\t\t\tfloat avg = (float) sum/counter; \n\t\t\tString emitValue = sum + \"\t\" + avg; \n\t\t\tcollect.collect(key, new Text(emitValue));\t\n\t\t} \n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_322_p0.java", :java => "// https://searchcode.com/api/result/100948405/\n\t\tText vword = new Text();\n\t\tpublic void reduce(Text key, Iterable<DoubleWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tdouble max = 0.0;\n\t\t\tfor(DoubleWritable value : values)\n\t\t\t{\n\t\t\t\tdouble current = value.get();\n\t\t\t\tmax = (max>current)?max:current;\n\t\t\t\tmin = (min<current)?min:current;\n\t\t\t}\n\t\t\tvword.set(\"Min: \" + min + \"\tMax: \" + max);\n\t\t\tcontext.write(key, vword);\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_667_p0.java", :java => "// https://searchcode.com/api/result/69347254/\n\n  public void reduce(Text key,\n                     Iterator<DoubleWritable> values,\n                     OutputCollector<Text, DoubleWritable> output,\n                     Reporter reporter) throws IOException {\n    //Key is label,word, value is the tfidf of the feature  of times we\'ve seen this label word per local node.  Output is the same\n\n    double sum = 0.0;\n    while (values.hasNext()) {\n      sum += values.next().get();\n    }\n    output.collect(key, new DoubleWritable(sum));\n  }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_25_p0.java", :java => "// https://searchcode.com/api/result/46623422/\n\t\t\n\t\tprivate IntWritable result = new IntWritable();\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.apache.hadoop.mapreduce.Reducer#reduce(java.lang.Object, java.lang.Iterable, org.apache.hadoop.mapreduce.Reducer.Context)\n\t\t */\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values) {\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
puts "Benchmarks 2018 done"