// https://searchcode.com/api/result/69649499/

package ncsa.d2k.modules.core.discovery.ruleassociation.fpgrowth;

//==============
// Java Imports
//==============
import java.beans.PropertyVetoException;
import java.util.*;

//===============
// Other Imports
//===============
import ncsa.d2k.core.modules.*;
import ncsa.d2k.modules.core.discovery.ruleassociation.*;


public class FPGrowth extends ncsa.d2k.core.modules.ComputeModule {

//==============
// Data Members
//==============

  private ArrayList _patterns = null;
  private ArrayList _problems = null;

  /** this is the number of sets that must contain a given rule for it to
   meet the support. */
  int cutoff;

//============
// Properties
//============

  /** minimum support, expressed as a percentage. */
  double support = 20.0;

      /** this property is the min acceptable support, expressed as a percentage. */
  public void setMinimumSupport(double d) throws PropertyVetoException {
    if (d <= 0.0 || 100.0 < d) {
      throw new PropertyVetoException(
          " Minimum Support % must be greater than 0 and less than or equal to 100.",
          null);
    }
    this.support = d;
  }

  public double getMinimumSupport() {
    return this.support;
  }

  /**
   * the maximum number of attributes that will be included in any rule
   */
  private int maxSize = 6;
  public void setMaxRuleSize(int yy) throws PropertyVetoException {
    if (yy < 2) {
      throw new PropertyVetoException(
          " Maximum Items per Rule cannot be less than 2.",
          null);
    }
    maxSize = yy;
  }

  public int getMaxRuleSize() {
    return this.maxSize;
  }

  /**
   * the showProgress property.
   */
  private boolean _verbose = true;
  public void setVerbose(boolean yy) {
    this._verbose = yy;
  }

  public boolean getVerbose() {
    return this._verbose;
  }

  /**
   * the Debug property.
   */
  private boolean debug = false;
  public void setDebug(boolean yy) {
    this.debug = yy;
  }

  public boolean getDebug() {
    return this.debug;
  }


//================
// Constructor(s)
//================

  public FPGrowth() {
  }

//================
// Public Methods
//================

  /**
   * Return the human readable name of the module.
   * @return the human readable name of the module.
   */
  public String getModuleName() {
    return "FPGrowth";
  }

  public void beginExecution() {
    _problems = null;
    _patterns = null;
  }

  public void endExecution() {
    super.endExecution();
    _problems = null;
    _patterns = null;
  }

  /**
   This method returns the description of the module.
   @return the description of the module.
   */
  public String getModuleInfo() {
    StringBuffer sb = new StringBuffer("<p>Overview: ");
    sb.append("This module implements the FPGrowth algorithm to generate frequent itemsets consisting of ");
    sb.append("items that occur in a sufficient number of examples to satisfy the minimum support criteria. ");

    sb.append("</p><p>Detailed Description: ");
    sb.append("This module takes an <i>Item Sets</i> object that has been generated by a <i>Table To Item Sets</i> ");
    sb.append("module and uses the FPGrowth algorithm to find ");
    sb.append("the combinations of items that satisfy a minimum support criteria. ");
    sb.append("An item is an [attribute,value] pair that occurs in the set of examples being mined. ");
    sb.append("The user controls the support criteria via the <i>Minimum Support %</i> property that specifies the ");
    sb.append("percentage of all examples that must contain a given combination of items ");
    sb.append("before that combination is included in the generated output. ");
    sb.append("Each combination of items that satisfies the <i>Minimum Support %</i> is called ");
    sb.append("a <i>Frequent Itemset</i>. ");

    sb.append("</p><p> ");
    sb.append("The user can restrict the maximum number of items included in any frequent itemset with ");
    sb.append("the <i>Maximum Items Per Rule</i> property.  The generation of sets with large number of items ");
    sb.append("can be computationally expensive, so setting this property in conjunction with the <i>Minimum Support %</i> ");
    sb.append("property helps keep the module runtime reasonable. ");

    sb.append("</p><p>");
    sb.append("In a typical itinerary the <i>Frequent Item Sets</i> output port from this module is connected to ");
    sb.append("a <i>Compute Confidence</i> module which forms ");
    sb.append("association rules that satisfy a minimum confidence value. ");

    sb.append("</p><p>References: ");
    sb.append("For more information on the FPGrowth frequent pattern mining algorithm, see &quot;Mining Frequent Patterns ");
    sb.append("without Candidate Generation&quot;Jiawei Han, Jian Pei, and Yiwen Yin, 2000. ");

    sb.append("</p><p>Limitations: ");
    sb.append("The <i>FPGrowth</i> and <i>Compute Confidence</i> modules currently ");
    sb.append("build rules with a single item in the consequent.  ");

    sb.append("</p><p>Data Type Restrictions: ");
    sb.append("While this module can operate on attributes of any datatype, in practice it is usually infeasible ");
    sb.append("to use it with continuous-valued attributes.   The module considers each [attribute,value] pair that occurs ");
    sb.append("in the examples individually when building the frequent itemsets.  Continuous attributes (and categorical ");
    sb.append("attributes with a large number of values) are less likely to meet the Minimum Support requirements ");
    sb.append("and can result in unacceptably long execution time.  Typically <i>Choose Attributes</i> and <i>Binning</i> ");
    sb.append("modules should appear in the itinerary prior to the <i>Table to Item Sets</i> module, whose output produces ");
    sb.append("the <i>Item Sets</i> object used as input by this module.   The Choosing/Binning modules can reduce the ");
    sb.append("number of distinct [attribute,value] pairs that must be considered in this module to a reasonable number. ");

    sb.append("</p><p>Data Handling: ");
    sb.append("This module does not modify the input Item Sets in any way. ");

    sb.append("</p><p>Scalability: ");
    sb.append("This module creates an array of integers to hold the indices of the items in each frequent itemset. ");
    sb.append("The module may be computationally intensive, and scales with the number of Item Sets entries to search. ");
    sb.append("The user can limit the size of the frequent itemsets although this will have little effect on performance for ");
    sb.append("this algorithm. Choosing and Binning modules can be included in the itinerary ");
    sb.append("prior to this modules to reduce the number of Item Sets entries.  </p>");
    return sb.toString();
  }

  /**
   * Return a list of the property descriptions.
   * @return a list of the property descriptions.
   */
  public PropertyDescription[] getPropertiesDescriptions() {
    PropertyDescription[] pds = new PropertyDescription[4];
    pds[0] = new PropertyDescription("minimumSupport",
                                     "Minimum Support %",
        "The percent of all examples that must contain a given set of items " +
        "before an association rule will be formed containing those items. " +
        "This value must be greater than 0 and less than or equal to 100.");
    pds[1] = new PropertyDescription(
        "maxRuleSize",
        "Maximum Items per Rule",
        "The maximum number of items to include in any rule. Does not impact performance for this algorithm as it does for Apriori." +
        "This value cannot be less than 2.");
    pds[2] = new PropertyDescription(
        "verbose",
        "Generate Verbose Output",
        "If this property is true, the module will report progress information to the console.");
    pds[3] = new PropertyDescription(
        "debug",
        "Generate Debug Output",
        "If this property is true, the module will write verbose status information to the console.");
    return pds;
  }


  /**
   * Return the human readable name of the indexed input.
   * @param index the index of the input.
   * @return the human readable name of the indexed input.
   */
  public String getInputName(int index) {
    switch (index) {
      case 0:
        return "Item Sets";
      default:
        return "No such input.";
    }
  }

  /**
   This method returns the description of the various inputs.
   @return the description of the indexed input.
   */
  public String getInputInfo(int index) {
    switch (index) {
      case 0:
        return "An object produced by a <i>Table To Item Sets</i> module " +
            "containing items that will appear in the frequent itemsets. ";
      default:
        return "No such input";
    }
  }

  /**
   This method returns an array of strings that contains the data types for the inputs.
   @return the data types of all inputs.
   */
  public String[] getInputTypes() {
    String[] types = {
        "ncsa.d2k.modules.core.discovery.ruleassociation.ItemSets"};
    return types;
  }

  /**
   * Return the human readable name of the indexed output.
   * @param index the index of the output.
   * @return the human readable name of the indexed output.
   */
  public String getOutputName(int index) {
    switch (index) {
      case 0:
        return "Frequent Itemsets";
      default:
        return "No such output.";
    }
  }

  /**
   This method returns the description of the outputs.
   @return the description of the indexed output.
   */
  public String getOutputInfo(int index) {
    switch (index) {
      case 0:
        String s =
            "A representation of the frequent itemsets found by the module. " +
            "This representation encodes the items used in the sets " +
            "and the number of examples in which each set occurs. This output is typically " +
            "connected to a <i>Compute Confidence</i> module.";
        return s;
      default:
        return "No such output";
    }
  }

  /**
   This method returns an array of strings that contains the data types for the outputs.
   @return the data types of all outputs.
   */
  public String[] getOutputTypes() {
    String[] types = {
        "[[I"};
    return types;
  }




  protected void doit() throws java.lang.Exception {

    long start = System.currentTimeMillis();

    try {

      ItemSets iss = (ItemSets)this.pullInput(0);
      HashMap sNames = iss.unique;
      int[] targetIndices = iss.targetIndices;
      String[] nameAry = iss.names;
      int numExamples = iss.numExamples;

      cutoff = (int) ( (double) numExamples * (support / 100.0));
      if ( ( (double) numExamples * (support / 100.0)) > (double) cutoff) {
        cutoff++;
      }

      // BUILD INITIAL PROBLEM
      FPProb prob = null;

      boolean[][] vals = iss.getItemFlags();
      FPSparse tab = new FPSparse(nameAry.length);
      FPPattern.clearElementMapping();
      for (int i = 0, n = nameAry.length; i < n; i++){
        tab.addColumn(i);
        FPPattern.addElementMapping(i, nameAry[i]);
      }
      for (int i = 0, n = vals.length; i < n; i++){
        for (int j = 0, m = vals[i].length; j < m; j++){
          if (vals[i][j] == true){
            tab.setInt(1, i, j);
          }
        }
      }
      int[] flist = new int[0];
      prob = new FPProb(tab, flist, cutoff);

      _patterns = new ArrayList();
      _problems = new ArrayList();

      FPProcess(prob);

        System.out.println("\n\n" + _patterns.size() + " patterns discovered.");
        long stop = System.currentTimeMillis();
        System.out.println((stop-start)/1000 + " seconds");


//        for (int i = 0, n = _patterns.size(); i < n; i++){
//          FPPattern pat = (FPPattern)_patterns.get(i);
//          System.out.print(pat.getSupport() + ":");
//          for (gnu.trove.TIntIterator it = pat.getPattern(); it.hasNext(); ){
//            int fte = (int)it.next();
//            System.out.print(" " + FPPattern.getElementLabel(fte));
//          }
//          System.out.println();
//        }


        int numpatsout = 0;

        gnu.trove.TIntIntHashMap tiihm = new gnu.trove.TIntIntHashMap();
        for (int i = 0, n = _patterns.size(); i < n; i++){
          FPPattern pat = (FPPattern)_patterns.get(i);
          int sz = pat.getSize();
          int val = tiihm.get(sz);
          val++;
          tiihm.put(sz, val);
        }
        int[] keys = tiihm.keys();
        for (int i = 0, n = keys.length; i < n; i++){
          if ((keys[i] < 2) || (keys[i] > this.getMaxRuleSize())) {
            numpatsout += tiihm.get(keys[i]);
            continue;
          }
          System.out.println("Number of frequent " + keys[i] + "-patterns: " + tiihm.get(keys[i]));
        }

     //CONVERT TO FORMAT USED BY COMPUTE CONFIDENCE MODULE

     int totnum = _patterns.size()-numpatsout;

     int[][] ovals = new int[totnum][];
     int ocnt = 0;
     for (int i = 0, n = _patterns.size(); i < n; i++){
       FPPattern pat = (FPPattern)_patterns.get(i);
       if ((pat.getSize() < 2) || (pat.getSize() > this.getMaxRuleSize())) {
         continue;
       }
       int[] fp = new int[pat.getSize() + 1];
       int cnter = 0;
       for (gnu.trove.TIntIterator it = pat.getPattern(); it.hasNext(); ){
         fp[cnter++] = (int)it.next();
       }
       fp[cnter] = pat.getSupport();
       ovals[ocnt++] = fp;
     }

     if (totnum != ocnt){
       System.out.println("Error: counts not right for total patterns output -- expected " + totnum + " -- produced " + ocnt);
     }

      if (_patterns.size() > 0){
        this.pushOutput(ovals, 0);
      }

    }
    catch (Exception ex) {
      ex.printStackTrace();
      System.out.println(ex.getMessage());
      System.out.println("ERROR: FPTreeGrowth.doit()");
      throw ex;
    }
  }

  //=================
  // Private Methods
  //=================

  private void FPProcess(FPProb prob){

//    if (DEBUG) {
//      System.out.println(">>>> EXECUTING FPPpocess ...");
//      System.out.println("Columns: " + prob.getTable().getNumColumns() + " Rows: " + prob.getTable().getNumRows());
//      System.out.print("Alpha: ");
//      for (int i = 0, n = prob.getAlpha().length; i<n ;i++){
//        System.out.print(FPPattern.getElementLabel(prob.getAlpha()[i]));
//      }
//      System.out.println();
//      System.out.println("Support: " + prob.getSupport());
//      System.out.println();
//    }


    FPTreeNode root = new FPTreeNode(-1, null, -1, -1);

    int[] alpha = prob.getAlpha();
    FPSparse tab = prob.getTable();
    int support = prob.getSupport();

    //Build header table
    TreeSet tfeats = new TreeSet(new Feature_Comparator());
    for (int i = 0, n = tab.getNumColumns(); i < n; i++){
      int coltot = tab.getColumnTots(i);
//      if (DEBUG){
//        System.out.println("Column " + FPPattern.getElementLabel(tab.getLabel(i)) + " has " + coltot + " sum of entries.");
//      }
      if (coltot >= support){
        tfeats.add(new FeatureTableElement(tab.getLabel(i), coltot, i));
      }
    }
//    if (DEBUG){
//      System.out.println("Feature tree set has " + tfeats.size() + " entries.");
//    }

    //trim the list
    ArrayList headers = new ArrayList();
    boolean b = true;
    for (Iterator it = tfeats.iterator(); it.hasNext(); ){
      FeatureTableElement fte = (FeatureTableElement)it.next();
//      if (DEBUG){
//        System.out.println(">> Header: " + FPPattern.getElementLabel(fte.getLabel()) + " :" + fte.getCnt());
//      }
      headers.add(fte);
    }
//    if (DEBUG){
//      System.out.println("Header table built with " + headers.size() + " entries.");
//    }

    int leafcnt = 0;
//    int nodecnt = 0;
    //build the FPTree
    for (int i = 0, n = tab.getNumRows(); i < n; i++){
      FPTreeNode current = root;
      for (int j = 0, m = headers.size(); j < m; j++){
        FeatureTableElement fte = (FeatureTableElement)headers.get(j);
        int val = tab.getInt(i, fte.getPosition());
        if (val > 0){
          FPTreeNode next = current.getChild(fte.getLabel());
          if (next == null) {
            if (current.isRoot() || (current.getNumChildren() > 0)){
              leafcnt++;
            }
            next = new FPTreeNode(fte.getLabel(), current, val, j);
//            nodecnt++;
            fte.addPointer(next);
            current.addChild(next);
          }
          else {
            next.inc(val);
          }
          current = next;
        }
      }
    }

//    if (DEBUG){
//      System.out.println("FPTree built with " + nodecnt + " nodes.");
//      System.out.println("Root has " + root.getNumChildren() + " children.");
//    }

//    if (DEBUG) {
//      int[] keys = root.getChildren().keys();
//      for (int i = 0, n = keys.length; i < n; i++){
//        FPTreeNode node = root.getChild(keys[i]);
//        while ((node != null)){
//          System.out.print(FPPattern.getElementLabel(node.getLabel()) + ":" + node.getCount() + " ");
//          //gnu.trove.TIntObjectIterator it = node.getChildren().iterator();
//          //it.advance();
//          //node = (FPTreeNode)it.value();
//          if (node.getChildren().size() > 0){
//            node = node.getChild(node.getChildren().keys()[0]);
//          } else {
//            //System.out.print(FPPattern.getElementLabel(node.getLabel()) + ":" + node.getCount() + " ");
//            node = null;
//          }
//        }
//        System.out.println();
//      }
//    }

    //========================================================================
    // BEGIN FPGROWTH ========================================================
    //========================================================================

    /**
     * If the tree is null, return
     */

    if (leafcnt == 0){
      return;
    }

    /**
     * If the tree has only one path, ouput all pattern combinations union alpha.
     */
    if (leafcnt == 1){
      ArrayList path = new ArrayList();
      FPTreeNode cpathnode = (FPTreeNode) ( (Object[]) root.getChildren().getValues())[0];
      while (true) {
        path.add(cpathnode);
        if (cpathnode.getNumChildren() == 0){
          break;
        }
        cpathnode = (FPTreeNode) ( (Object[]) cpathnode.getChildren().getValues())[0];
      }
//      if (DEBUG){
//        System.out.println("\n\nOuput path info for one path -------");
//        for (int i = 0, n = path.size(); i < n; i++){
//          System.out.print( FPPattern.getElementLabel(((FPTreeNode)path.get(i)).getLabel()) + ":" + ((FPTreeNode)path.get(i)).getCount() + " ");
//        }
//        System.out.println("\n\n");
//      }
      //now we need to get the combinations.
      ArrayList param = new ArrayList(path);
      //int supp =  ((FPTreeNode)path.get(path.size()-1)).getCount();
      combos2(param,alpha);
      return;
    }


    /**
     * else, take each feature from header table (in reverse support order) and
     * output that feature|union alpha as a pattern, create a new patterns DB,
     * create new FPProb, and finally call FPProcess.
     */
    for (int a = headers.size()-1; a >= 0; a--){

      FeatureTableElement fte = (FeatureTableElement)headers.get(a);
      List ptrs = fte.getPointers();

      //add the entry in the table union alpha
      FPPattern pat = new FPPattern(alpha, fte.getCnt());
      pat.addPatternElt(fte.getLabel());
      _patterns.add(pat);

      FPSparse otab = new FPSparse(headers.size());
      int[] colmap = new int[headers.size()];
      int cind = 1;

      //create new pattern DB
      int cnter = 0;
      for (int i2 = 0, n2 = ptrs.size(); i2 < n2; i2++){
        FPTreeNode node = (FPTreeNode)ptrs.get(i2);
        List l = this.getPath(node);
        for (int i3 = 0, n3 = l.size(); i3 < n3; i3++){
          FPTreeNode node2 = (FPTreeNode)l.get(i3);
          if (colmap[node2.getPosition()] == 0){
            otab.addColumn(((FeatureTableElement)headers.get(node2.getPosition())).getLabel());
            colmap[node2.getPosition()] = cind;
            cind++;
          }
          otab.setInt(node.getCount(), cnter, colmap[node2.getPosition()]-1);
        }
        if (l.size() > 0)cnter++;
      }

      //build a new prob and submit it for processing
      int[] newalpha = new int[alpha.length + 1];
      System.arraycopy(alpha,0,newalpha,0,alpha.length);
      newalpha[newalpha.length-1] = fte.getLabel();
//      if (DEBUG){
//        System.out.println("Calling FPProcess on conditional table for: " + fte.getLabel());
//      }
      FPProb newprob = new FPProb(otab, newalpha, support);
      FPProcess(newprob);
    }

  }

  private void combos2 (List list, int[] alpha) {
      int pattern_len, i;
      int[] ind = new int[list.size() + 1];
      pattern_len = list.size();
      if (pattern_len > 0) {
          //initialize index
          while (ind[pattern_len] == 0) {
              //adjust index
              i = 0;
              ind[i]++;
              while (ind[i] > 1) {
                  ind[i] = 0;
                  ind[++i]++;
              }
              if (ind[pattern_len] == 0) {
                  FPPattern pat = new FPPattern(alpha, 0);
                  int min = Integer.MAX_VALUE;
                  for (i = pattern_len - 1; i >= 0; i--) {
                      if (ind[i] == 1) {
                        FPTreeNode nd = (FPTreeNode)list.get(i);
                        pat.addPatternElt(nd.getLabel());
                        if (nd.getCount() < min){
                          min = nd.getCount();
                        }
                      }
                  }
                  pat.setSupport(min);
                  _patterns.add(pat);
              }
          }
      }
  }


  private List getPath(FPTreeNode node){
    ArrayList list = new ArrayList();
    if (node.isRoot()){
      return list;
    }
    node = node.getParent();
    while(true){
      if (node.isRoot()){
        return list;
      }
      list.add(node);
      node = node.getParent();
    }
  }



  //=============
  // Inner Class
  //=============
  private class Feature_Comparator
      implements java.util.Comparator {
    /** The small deviation allowed in double comparisons */

    /**
     * put your documentation comment here
     */
    public Feature_Comparator() {
    }

    //======================
    //Interface: Comparator
    //======================
    public int compare(Object o1, Object o2) {
      FeatureTableElement fte1 = (FeatureTableElement) o1;
      FeatureTableElement fte2 = (FeatureTableElement) o2;
      if (fte1.getCnt() == fte2.getCnt()) {
        if (fte1.getLabel() > fte2.getLabel()) {
          return 1;
        } else if (fte1.getLabel() < fte2.getLabel()) {
          return -1;
        } else {
          System.out.println("ERROR ERROR ERROR: We never want to go here ...");
          return 0;
        }
      } else if (fte1.getCnt() > fte2.getCnt())  {
        return -1;
      } else {
        return 1;
      }
    }

    /**
     * put your documentation comment here
     * @param o
     * @return
     */
    public boolean equals(Object o) {
      return this.equals(o);
    }
  }


}
