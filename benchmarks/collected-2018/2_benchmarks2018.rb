Testcase.create(:name => "bitbucket2_50-250_197_p0.java", :java => "// https://searchcode.com/api/result/48924593/\n\t\tpublic void reduce (final IntWritable key, final Iterator<DoubleWritable> values, final OutputCollector<IntWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint i = 0;\n\t\t\tdouble val_double[] = new double[2];\n\t\t\tval_double[0] = 0;\n\t\t\tval_double[1] = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tval_double[i] = values.next().get();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdouble result = val_double[0] + val_double[1];\n\t\t\tif( result != 0 )\n\t\t\t\toutput.collect(key, new DoubleWritable(result));\n\t\t}\n", :t1 => "IntWritable", :t2 => "DoubleWritable", :t3 => "IntWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample from these testcases. ")
Testcase.create(:name => "github2_50-250_162_p0.java", :java => "// https://searchcode.com/api/result/66797561/\n\t\t\n\t\t/*\n\t\t * This method should calculate the maximum row length for each file \n\t\t */\n\t\tpublic void reduce(Text fileName, Iterable<IntWritable> arg1, Context context) throws IOException ,InterruptedException {\n\t\t\t\n\t\t\t\n\t\t\tint maxValue = Integer.MIN_VALUE;\n\t\t\t\n\t\t\t//TODO: calculate the maximum row length per fileName\n\n\t\t\tcontext.write(fileName, new IntWritable(maxValue));\n\t\t};\n\t\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_450-650_93_p1.java", :java => "// https://searchcode.com/api/result/10576150/\n      \n      public void reduce(BytesWritable key, Iterator<IntWritable> values,\n                         OutputCollector<BytesWritable, IntWritable> output,\n                         Reporter reporter) throws IOException {\n\tIntWritable sortInput = new IntWritable(1);\n\tIntWritable sortOutput = new IntWritable(2);\n        int ones = 0;\n        int twos = 0;\n        while (values.hasNext()) {\n          IntWritable count = values.next(); \n          if (count.equals(sortInput)) {\n            ++ones;\n          } else if (count.equals(sortOutput)) {\n            ++twos;\n          } else {\n            throw new IOException(\"Invalid \'value\' of \" + count.get() + \n                                  \" for (key,value): \" + key.toString());\n          }\n        }\n        \n        // Check to ensure there are equal no. of ones and twos\n        if (ones != twos) {\n          throw new IOException(\"Illegal (\'one\', \'two\'): (\" + ones + \", \" + twos +\n                                \") for (key, value): \" + key.toString());\n        }\n      }\n", :t1 => "BytesWritable", :t2 => "IntWritable", :t3 => "BytesWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p0.java", :java => "// https://searchcode.com/api/result/110747437/\n    \n    public void configure(JobConf job) {\n    }\n\n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      while (it.hasNext()) {\n        out.collect(it.next(), null);\n      }\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github2_50-250_6_p0.java", :java => "// https://searchcode.com/api/result/93068483/\n    private IntWritable result = new IntWritable();\n  \n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context) throws IOException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_151_p0.java", :java => "// https://searchcode.com/api/result/59025411/\n\t\t/**\n\t\t * Reduce method which implements summation. Acts as both reducer and\n\t\t * combiner.\n\t\t * \n\t\t * @throws IOException\n\t\t */\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\n\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<IntWritable> iterator = values.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tsum += iterator.next().get();\n\t\t\t}\n\t\t\tcontext.write(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_318_p0.java", :java => "// https://searchcode.com/api/result/100948358/\n/*\n\t\tMap<String, String> info = null;\n\t\tpublic void setup(Context context) throws IOException\n        {\n                loadKeys(context);\n        }\n        void loadKeys(Context context) throws IOException\n        {\n                FSDataInputStream in = null;\n                BufferedReader br = null;\n                FileSystem fs = FileSystem.get(context.getConfiguration());\n                Path path = new Path(filePath);\n                in = fs.open(path);\n                br  = new BufferedReader(new InputStreamReader(in));\n                info = new HashMap<String, String>();\n                String line = \"\";\n                while ( (line = br.readLine() )!= null) {\n                String[] arr = line.split(\"\\,\");\n                if (arr.length == 2)\n                \tinfo.put(arr[0], arr[1]);\n                }\n                in.close();\n        }\n\t*/\n        Text kword = new Text();\n\t\tLongWritable vword = new LongWritable();\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\t//String myKey = key.toString() + \"\t\" + info.get(key.toString());\n\t\t\tString myKey = key.toString() + \"\t\";\n\t\t\tkword.set(myKey);\n\t\t\tvword.set(sum);\n\t\t\tcontext.write(kword, vword);\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_556_p0.java", :java => "// https://searchcode.com/api/result/65663358/\n/*\n    private TopNScoredObjects<Integer> queue;\n\n    public void setup(Reducer<IntWritable, FloatWritable, IntWritable, FloatWritable>.Context context)\n        throws IOException {\n      int k = context.getConfiguration().getInt(\"n\", 100);\n      queue = new TopNScoredObjects<Integer>(k);\n    }\n    */\n\n    public void reduce(IntWritable nid, Iterable<FloatWritable> iterable, Context context)\n        throws IOException {\n      Iterator<FloatWritable> iter = iterable.iterator();\n      //queue.add(nid.get(), iter.next().get());\n      float f = iter.next().get();\n\n      // Shouldn\'t happen. Throw an exception.\n      if (iter.hasNext()) {\n        //throw new RuntimeException();\n        return;\n      }\n    }\n\n/*\n    public void cleanup(Reducer<IntWritable, FloatWritable, IntWritable, FloatWritable>.Context context)\n        throws IOException, InterruptedException {\n      IntWritable key = new IntWritable();\n      FloatWritable value = new FloatWritable();\n\n      for (PairOfObjectFloat<Integer> pair : queue.extractAll()) {\n        key.set(pair.getLeftElement());\n        value.set(pair.getRightElement());\n        context.write(key, value);\n      }\n    }\n    */\n", :t1 => "IntWritable", :t2 => "FloatWritable", :t3 => "IntWritable", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_450-650_1_p2.java", :java => "// https://searchcode.com/api/result/87881700/\n    \n    public void configure(JobConf job) {\n    }\n\n    // keep track of the last key we\'ve seen\n    private int lastKey = Integer.MIN_VALUE;\n    public void reduce(IntWritable key,\n                       Iterator<IntWritable> values,\n                       OutputCollector<IntWritable, Text> out,\n                       Reporter reporter) throws IOException {\n      // check key order\n      int currentKey = key.get();\n      if (currentKey < lastKey) {\n      }\n      lastKey = currentKey;\n      // check order of values\n      IntWritable previous = new IntWritable(Integer.MIN_VALUE);\n      int valueCount = 0;\n      while (values.hasNext()) {\n        IntWritable current = values.next();\n        \n        // Check that the values are sorted\n        if (current.compareTo(previous) < 0)\n        previous = current;\n        ++valueCount;\n      }\n      if (valueCount != 5) {\n      }\n      out.collect(key, new Text(\"success\"));\n    }\n\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_112_p0.java", :java => "// https://searchcode.com/api/result/92069172/\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n        {\n            int sum = 0;\n            for (IntWritable val : values)\n                sum += val.get();\n            context.write(key, new IntWritable(sum));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_312_p0.java", :java => "// https://searchcode.com/api/result/112786286/\n        private Text current = new Text();\n        private int marginalCount = 2;\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException\n        {\n\t\t/*\n            if (!key.fst.equals(current)) {\n                if (!key.snd.equals(MARGINAL))\n                    return;\n                current.set(key.fst);\n                marginalCount = 0;\n                for (IntWritable x : values)\n                    marginalCount += x.get();\n                return;\n            }\n\t    */\n            // control only gets here if we are using the same marginal\n            int myCount = 0;\n            for (IntWritable x : values)\n                myCount += x.get();\n            context.write(key, new DoubleWritable(myCount / (double) marginalCount));\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_151_p0.java", :java => "// https://searchcode.com/api/result/74259363/\n\n    public void reduce(Text key, Iterator<IntWritable> values,\n                       OutputCollector<Text, IntWritable> output,\n                       Reporter reporter) throws IOException {\n      int sum = 0;\n      while (values.hasNext()) {\n        sum += values.next().get();\n      }\n      output.collect(key, new IntWritable(sum));\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_58_p0.java", :java => "// https://searchcode.com/api/result/48927360/\n\n  private int minSupport = 0;\n\n  public void reduce(Text key, Iterable<LongWritable> values, Context context)\n    throws IOException, InterruptedException {\n    long sum = 0;\n    for (LongWritable value : values) {\n      sum += value.get();\n    }\n    if (sum >= minSupport) {\n      context.write(key, new LongWritable(sum));\n    }\n  }\n\n/*\n  protected void setup(Context context) throws IOException, InterruptedException {\n    super.setup(context);\n    minSupport = context.getConfiguration().getInt(DictionaryVectorizer.MIN_SUPPORT,\n                                                   DictionaryVectorizer.DEFAULT_MIN_SUPPORT);\n  }\n\n  */\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_216_p0.java", :java => "// https://searchcode.com/api/result/65663892/\n\t\tprivate final FloatWritable sumWritable = new FloatWritable();\n\n\t\tpublic void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tIterator<FloatWritable> iter = values.iterator();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsum += iter.next().get();\n\t\t\t}\n\t\t\tsumWritable.set(sum);\n\t\t\tcontext.write(key, sumWritable);\n\t\t}\n", :t1 => "Text", :t2 => "FloatWritable", :t3 => "Text", :t4 => "FloatWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_84_p0.java", :java => "// https://searchcode.com/api/result/119749254/\n\n    // reuse objects\n    private final IntWritable SumValue = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, Context context) \n      throws IOException, InterruptedException {\n\n      // sum up values\n      Iterator<IntWritable> iter = values.iterator();\n      int sum = 0;\n      while (iter.hasNext()) {\n\tsum += iter.next().get();\n      }\n      SumValue.set(sum);\n      context.write(key, SumValue);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_398_p0.java", :java => "// https://searchcode.com/api/result/93911511/\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next().get();\n            }\n            result.set(sum);\n            output.collect(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_158_p0.java", :java => "// https://searchcode.com/api/result/140067130/\n\t\tpublic void reduce( Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile( values.hasNext() ) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect( key, new IntWritable( sum ) );\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_250-450_81_p1.java", :java => "// https://searchcode.com/api/result/93179565/\n\n\t\tpublic void reduce(IntWritable k, Iterator<IntWritable> v, OutputCollector<IntWritable, IntWritable> out, Reporter r)\n\t\t\t\tthrows IOException {\n\t\t\twhile(v.hasNext()) {\n\t\t\t\tout.collect(new IntWritable(k.get() % 4), v.next());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void configure(JobConf arg0) { }\n\n\t\tpublic void close() throws IOException { }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_650-850_0_p2.java", :java => "// https://searchcode.com/api/result/74259923/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int total = 0;\n      while (it.hasNext()) {\n        total += it.next().get();\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(total));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_22_p0.java", :java => "// https://searchcode.com/api/result/99975914/\n\t\tpublic void reduce(Text key, Iterator<DoubleWritable> values, OutputCollector<Text, DoubleWritable> output, Reporter reporter) throws IOException {\n\t\t\tdouble stdDev = 0;\n\t\t\tdouble sumSqr = 0;\n\t\t\tdouble count = 0;\n\t\t\tdouble mean = 0;\n\t\t\tdouble sum = 0;\n\t\t\twhile(values.hasNext()){\n\t\t\t\tdouble value = values.next().get();\n\t\t\t\tsumSqr += value*value;\n\t\t\t\tsum += value;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmean = sum/count;\n\t\t\tstdDev = Math.sqrt((sumSqr-count*mean*mean)/count);\n\t\t\toutput.collect(key, new DoubleWritable(stdDev));\n\t\t}\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 3, :result => "CANNOT prove to be commutative. Cannot find a counterexample. ")
Testcase.create(:name => "github_50-250_121_p0.java", :java => "// https://searchcode.com/api/result/100948419/\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\tcontext.write(key, new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_591_p0.java", :java => "// https://searchcode.com/api/result/65662332/\n    private final IntWritable cnt = new IntWritable(1);\n\n    public void reduce(IntWritable key, Iterable<IntWritable> values, Context context)\n        throws IOException, InterruptedException {\n      context.write(key, cnt);\n      cnt.set(cnt.get() + 1);\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_183_p0.java", :java => "// https://searchcode.com/api/result/116093382/\n\n    //private final Log LOG = LogFactory.getLog(LogCombiner.class);\n\n    public void reduce(final Text pKey, final Iterable<IntWritable> pValues, final Context pContext)\n        throws IOException, InterruptedException {\n\n        int count = 0;\n        for (IntWritable val : pValues) {\n            count += val.get();\n        }\n\n        pContext.write(pKey, new IntWritable(count));\n    }\n\n\n    public void close() throws IOException {\n    }\n\n    public void configure(final JobConf job) {\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_183_p1.java", :java => "// https://searchcode.com/api/result/116093382/\n    public void reduce(final Text key, final Iterator<IntWritable> values, final OutputCollector<Text, IntWritable> output,\n                       final Reporter reporter) throws IOException {\n        int count = 0;\n        while (values.hasNext()) {\n            count += values.next().get();\n        }\n\n        output.collect(key, new IntWritable(count));\n    }\n\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_250-450_147_p0.java", :java => "// https://searchcode.com/api/result/10576290/\n    protected final IntWritable one = new IntWritable(1);\n\n    int srcs = 0;\n    \n    /*\n    public void setup(Context context) {\n      srcs = context.getConfiguration().getInt(\"testdatamerge.sources\", 0);\n      assertTrue(\"Invalid src count: \" + srcs, srcs > 0);\n    }\n    */\n\n    public void reduce(IntWritable key, Iterable<IntWritable> values,\n        Context context) throws IOException, InterruptedException {\n      int seen = 0;\n      for (IntWritable value : values) {\n        seen += value.get();\n      }\n      //assertTrue(\"Bad count for \" + key.get(), verify(key.get(), seen));\n      context.write(key, new IntWritable(seen));\n    }\n    \n    //public abstract boolean verify(int key, int occ);\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_58_p0.java", :java => "// https://searchcode.com/api/result/74337136/\n\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context)\n\t\t\t\tthrows IOException, InterruptedException {\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable value : values)\n\t\t\t\tsum += value.get();\n\t\t\tcontext.write(key,new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_586_p0.java", :java => "// https://searchcode.com/api/result/65159880/\n\n        private IntWritable result = new IntWritable();\n\n        public void reduce(Text key, Iterable<IntWritable> values, Context context)\n                throws IOException, InterruptedException {\n            int sum = 0;\n            for(IntWritable val: values) {\n                sum += val.get();\n            }\n\n            result.set(sum);\n            context.write(key, result);\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_132_p0.java", :java => "// https://searchcode.com/api/result/65246202/\n    public void reduce( Text key, Iterator<LongWritable> values, OutputCollector<Text, LongWritable> output, Reporter reporter)\n      throws IOException\n    {\n      long sum = 0;\n\n      while ( values.hasNext( ) )\n        {\n          LongWritable value = values.next( );\n          \n          sum += value.get( );\n        }\n      \n      output.collect( key, new LongWritable( sum ) );\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_450-650_38_p6.java", :java => "// https://searchcode.com/api/result/48924581/\n\t\tpublic void reduce (final LongWritable key, final Iterator<DoubleWritable> values, final OutputCollector<LongWritable, DoubleWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tdouble sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tdouble cur_val = values.next().get();\n\t\t\t\tsum += cur_val;\n\t\t\t}\n\n\t\t\toutput.collect( key, new DoubleWritable( sum ) );\n\t\t}\n", :t1 => "LongWritable", :t2 => "DoubleWritable", :t3 => "LongWritable", :t4 => "DoubleWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github2_50-250_4_p0.java", :java => "// https://searchcode.com/api/result/74337389/\n\n  public void reduce(LongWritable offset, Iterable<LongWritable> vals,\n                        Context context) throws IOException,\n                                             InterruptedException {\n    // TODO: implement the reduce method\n  }\n  \n", :t1 => "LongWritable", :t2 => "LongWritable", :t3 => "LongWritable", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_650-850_18_p3.java", :java => "// https://searchcode.com/api/result/48924579/\n\t\tpublic void reduce (final IntWritable key, final Iterator<IntWritable> values, final OutputCollector<IntWritable, IntWritable> output, final Reporter reporter) throws IOException\n        {\n\t\t\tint sum = 0;\n\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tint cur_value = values.next().get();\n\t\t\t\tsum += cur_value;\n\t\t\t}\n\n\t\t\toutput.collect( key, new IntWritable(sum) );\n\t\t}\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_75_p0.java", :java => "// https://searchcode.com/api/result/102256879/\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values, \n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_317_p0.java", :java => "// https://searchcode.com/api/result/100948350/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, LongWritable> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t}\n\t\t\tcollect.collect(key, new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket2_50-250_27_p0.java", :java => "// https://searchcode.com/api/result/37260181/\n    public void reduce(Text pair, Iterable<DoubleWritable> values, Context ctx)\n      throws IOException, InterruptedException {\n      ctx.write(pair, values.iterator().next());\n    }\n", :t1 => "Text", :t2 => "DoubleWritable", :t3 => "Text", :t4 => "DoubleWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 2, :result => "CANNOT prove to be commutative. Counterexample found. ")
Testcase.create(:name => "github_50-250_420_p0.java", :java => "// https://searchcode.com/api/result/95819254/\n\t\tprivate IntWritable result = new IntWritable();\n\t\t\n\t\tpublic void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException{\n\t\t\tint sum = 0;\n\t\t\tfor (IntWritable val : values){\n\t\t\t\tsum += val.get();\n\t\t\t}\n\t\t\tresult.set(sum);\n\t\t\tcontext.write(key, result);\n\t\t}\n\t\t\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_320_p0.java", :java => "// https://searchcode.com/api/result/100948377/\n\t\tpublic void reduce(Text key, Iterator<LongWritable> values,\n\t\t\t\tOutputCollector<Text, Text> collect, Reporter reporter)\n\t\t\t\t\t\tthrows IOException {\n\t\t\tlong sum = 0;\n\t\t\tint counter = 0;\n\t\t\twhile(values.hasNext())\n\t\t\t{\n\t\t\t\tsum = sum + values.next().get();\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tfloat avg = (float) sum/counter;\n\t\t\tString emitValue = sum + \"\t\" + avg;\n\t\t\tcollect.collect(key, new Text(emitValue));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "Text", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_502_p1.java", :java => "// https://searchcode.com/api/result/2505957/\n        public void reduce( Text key, Iterable<LongWritable> values, Context context )\n                throws IOException, InterruptedException{\n            Long totalUploadFlow = new Long( 0 );\n            for ( LongWritable val : values ){\n                totalUploadFlow += val.get();\n            }\n            context.write( key, new LongWritable( totalUploadFlow ) );\n        }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_650-850_4_p1.java", :java => "// https://searchcode.com/api/result/110747437/\n    public void configure(JobConf job) {\n    }\n        \n    public void reduce(IntWritable key, Iterator<IntWritable> it,\n                       OutputCollector<IntWritable, IntWritable> out,\n                       Reporter reporter) throws IOException {\n      int keyint = key.get();\n      int count = 0;\n      while (it.hasNext()) {\n        it.next();\n        count++;\n      }\n      out.collect(new IntWritable(keyint), new IntWritable(count));\n    }\n    public void close() {\n    }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_39_p0.java", :java => "// https://searchcode.com/api/result/133129611/\n\t\tpublic void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {\n\t\t\tint sum = 0;\n\t\t\twhile (values.hasNext()) {\n\t\t\t\tsum += values.next().get();\n\t\t\t}\n\t\t\toutput.collect(key, new IntWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_94_p0.java", :java => "// https://searchcode.com/api/result/101728519/\n\n    public void configure(JobConf job) {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void close() throws IOException {\n      // TODO Auto-generated method stub\n      \n    }\n\n    public void reduce(Text key, Iterator<IntWritable> values,OutputCollector<Text, IntWritable> output, Reporter reporter)\n        throws IOException {\n      int count = 0;\n      while (values.hasNext()) \n        count += values.next().get();\n      if (count >= 10) { \n        output.collect(key, new IntWritable(count));\n      }\n    } \n    \n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_116_p0.java", :java => "// https://searchcode.com/api/result/100948332/\n\t\tpublic void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(LongWritable value : values)\n\t\t\t{\n\t\t\t\tsum = sum + value.get();\n\t\t\t}\n\t\t\t//String country = context.getConfiguration().get(\"country\");\n\t\t\tString country = \"_\";\n\t\t\tString record = country + \": \" + key.toString(); \n\t\t\tcontext.write(new Text(record), new LongWritable(sum));\n\t\t}\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "bitbucket_50-250_178_p0.java", :java => "// https://searchcode.com/api/result/37458208/\n    public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException {\n      long total = 0;\n\n      for (LongWritable val : values) {\n        total += val.get();\n      }\n\n      context.write(new LongWritable(total), key);\n    }\n", :t1 => "Text", :t2 => "LongWritable", :t3 => "Text", :t4 => "LongWritable", :r_type => "Context", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_60_p0.java", :java => "// https://searchcode.com/api/result/94159078/\n        public void reduce(IntWritable key, Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, Reporter reporter) throws IOException {\n            int count = 0;\n            while (values.hasNext()) count += values.next().get();\n            output.collect(key, new IntWritable(count));\n        }\n", :t1 => "IntWritable", :t2 => "IntWritable", :t3 => "IntWritable", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
Testcase.create(:name => "github_50-250_34_p0.java", :java => "// https://searchcode.com/api/result/94159083/\n        public void reduce( Text key, Iterator<IntWritable> values,\n                            OutputCollector<Text, IntWritable> output,\n                            Reporter reporter) throws IOException\n        {\n            // Iterate over all of the values (counts of occurrences of this word)\n            int count = 0;\n            while( values.hasNext() )\n            {\n                // Add the value to our count\n                count += values.next().get();\n            }\n\n            // Output the word with its count (wrapped in an IntWritable)\n            output.collect( key, new IntWritable( count ) );\n        }\n", :t1 => "Text", :t2 => "IntWritable", :t3 => "Text", :t4 => "IntWritable", :r_type => "Collector", :source => "2018", :comment => "", :result_type => 1, :result => "Proved to be commutative.")
